import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useCallback, useMemo, useState } from "react";
import { toTokens } from "../../../../../utils/units.js";
import { useCustomTheme } from "../../../../core/design-system/CustomThemeProvider.js";
import { fontSize, iconSize, radius, spacing, } from "../../../../core/design-system/index.js";
import { Container, noScrollBar } from "../../components/basic.js";
import { Button } from "../../components/buttons.js";
import { Img } from "../../components/Img.js";
import { Skeleton } from "../../components/Skeleton.js";
import { Spacer } from "../../components/Spacer.js";
import { Spinner } from "../../components/Spinner.js";
import { Text } from "../../components/text.js";
import { StyledDiv } from "../../design-system/elements.js";
import { useDebouncedValue } from "../../hooks/useDebouncedValue.js";
import { useIsMobile } from "../../hooks/useisMobile.js";
import { SearchInput } from "./SearchInput.js";
import { SelectChainButton } from "./SelectChainButton.js";
import { SelectBridgeChain } from "./select-chain.js";
import { useBridgeChains } from "./use-bridge-chains.js";
import { useTokenBalances, useTokens, } from "./use-tokens.js";
import { tokenAmountFormatter } from "./utils.js";
function findChain(chains, activeChainId) {
    if (!activeChainId) {
        return undefined;
    }
    return chains.find((chain) => chain.chainId === activeChainId);
}
const ALL_TOKENS_LIMIT = 100;
const OWNED_TOKENS_LIMIT = 50;
/**
 * @internal
 */
export function SelectToken(props) {
    const chainQuery = useBridgeChains(props.client);
    const [search, _setSearch] = useState("");
    const debouncedSearch = useDebouncedValue(search, 500);
    const [allTokensLimit, setAllTokensLimit] = useState(ALL_TOKENS_LIMIT);
    const [ownedTokensLimit, setOwnedTokensLimit] = useState(OWNED_TOKENS_LIMIT);
    const [_selectedChain, setSelectedChain] = useState(undefined);
    const selectedChain = _selectedChain ||
        (chainQuery.data
            ? findChain(chainQuery.data, props.selectedToken?.chainId) ||
                findChain(chainQuery.data, props.activeWalletInfo?.activeChain.id) ||
                findChain(chainQuery.data, 1)
            : undefined);
    // all tokens
    const tokensQuery = useTokens({
        client: props.client,
        chainId: selectedChain?.chainId,
        search: debouncedSearch,
        limit: allTokensLimit,
        offset: 0,
    });
    // owned tokens
    const ownedTokensQuery = useTokenBalances({
        clientId: props.client.clientId,
        chainId: selectedChain?.chainId,
        limit: ownedTokensLimit,
        page: 1,
        walletAddress: props.activeWalletInfo?.activeAccount.address,
    });
    const filteredOwnedTokens = useMemo(() => {
        return ownedTokensQuery.data?.tokens?.filter((token) => {
            return (token.symbol.toLowerCase().includes(debouncedSearch.toLowerCase()) ||
                token.name.toLowerCase().includes(debouncedSearch.toLowerCase()) ||
                token.token_address
                    .toLowerCase()
                    .includes(debouncedSearch.toLowerCase()));
        });
    }, [ownedTokensQuery.data?.tokens, debouncedSearch]);
    const setSearch = useCallback((search) => {
        _setSearch(search);
        setAllTokensLimit(ALL_TOKENS_LIMIT);
        setOwnedTokensLimit(OWNED_TOKENS_LIMIT);
    }, []);
    return (_jsx(SelectTokenUI, { ...props, ownedTokens: {
            data: filteredOwnedTokens || [],
            isFetching: ownedTokensQuery.isFetching,
            showMore: ownedTokensQuery.data?.pagination.hasMore
                ? () => {
                    setOwnedTokensLimit(ownedTokensLimit + OWNED_TOKENS_LIMIT);
                }
                : undefined,
        }, allTokens: {
            data: tokensQuery.data || [],
            isFetching: tokensQuery.isFetching,
            showMore: tokensQuery.data?.length === allTokensLimit
                ? () => {
                    setAllTokensLimit(allTokensLimit + ALL_TOKENS_LIMIT);
                }
                : undefined,
        }, selectedChain: selectedChain, setSelectedChain: setSelectedChain, search: search, setSearch: setSearch, selectedToken: props.selectedToken, setSelectedToken: props.setSelectedToken }));
}
function SelectTokenUI(props) {
    const isMobile = useIsMobile();
    const [screen, setScreen] = useState("select-token");
    // show tokens with icons first
    const sortedOwnedTokens = useMemo(() => {
        return props.ownedTokens.data.sort((a, b) => {
            if (a.icon_uri && !b.icon_uri) {
                return -1;
            }
            if (!a.icon_uri && b.icon_uri) {
                return 1;
            }
            return 0;
        });
    }, [props.ownedTokens.data]);
    // show tokens with icons first
    const sortedAllTokens = useMemo(() => {
        return props.allTokens.data.sort((a, b) => {
            if (a.iconUri && !b.iconUri) {
                return -1;
            }
            if (!a.iconUri && b.iconUri) {
                return 1;
            }
            return 0;
        });
    }, [props.allTokens.data]);
    // desktop
    if (!isMobile) {
        return (_jsxs(Container, { style: {
                display: "grid",
                gridTemplateColumns: "300px 1fr",
                height: "100%",
            }, children: [_jsx(LeftContainer, { children: _jsx(SelectBridgeChain, { onBack: () => setScreen("select-token"), client: props.client, isMobile: false, onSelectChain: (chain) => {
                            props.setSelectedChain(chain);
                            setScreen("select-token");
                        }, selectedChain: props.selectedChain }) }), _jsx(Container, { flex: "column", relative: true, scrollY: true, children: _jsx(TokenSelectionScreen, { onSelectToken: (token) => {
                            props.setSelectedToken(token);
                            props.onClose();
                        }, isMobile: false, selectedToken: props.selectedToken, ownedTokens: {
                            ...props.ownedTokens,
                            data: sortedOwnedTokens,
                        }, allTokens: {
                            ...props.allTokens,
                            data: sortedAllTokens,
                        }, selectedChain: props.selectedChain, onSelectChain: () => setScreen("select-chain"), client: props.client, search: props.search, setSearch: props.setSearch, isWalletConnected: props.activeWalletInfo !== undefined }) })] }));
    }
    if (screen === "select-token") {
        return (_jsx(TokenSelectionScreen, { isWalletConnected: props.activeWalletInfo !== undefined, onSelectToken: (token) => {
                props.setSelectedToken(token);
                props.onClose();
            }, selectedToken: props.selectedToken, ownedTokens: {
                ...props.ownedTokens,
                data: sortedOwnedTokens,
            }, allTokens: {
                ...props.allTokens,
                data: sortedAllTokens,
            }, selectedChain: props.selectedChain, isMobile: true, onSelectChain: () => setScreen("select-chain"), client: props.client, search: props.search, setSearch: props.setSearch }));
    }
    if (screen === "select-chain") {
        return (_jsx(SelectBridgeChain, { isMobile: true, onBack: () => setScreen("select-token"), client: props.client, onSelectChain: (chain) => {
                props.setSelectedChain(chain);
                setScreen("select-token");
            }, selectedChain: props.selectedChain }));
    }
    return null;
}
function TokenButtonSkeleton() {
    return (_jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: spacing.sm,
            padding: `${spacing.xs} ${spacing.xs}`,
            height: "70px",
        }, children: [_jsx(Skeleton, { height: `${iconSize.lg}px`, width: `${iconSize.lg}px` }), _jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "4px" }, children: [_jsx(Skeleton, { height: fontSize.sm, width: "100px" }), _jsx(Skeleton, { height: fontSize.md, width: "200px" })] })] }));
}
function TokenButton(props) {
    const theme = useCustomTheme();
    const tokenBalanceInUnits = "balance" in props.token
        ? toTokens(BigInt(props.token.balance), props.token.decimals)
        : undefined;
    const usdValue = "balance" in props.token
        ? props.token.price_data.price_usd * Number(tokenBalanceInUnits)
        : undefined;
    return (_jsxs(Button, { variant: props.isSelected ? "secondary" : "ghost-solid", fullWidth: true, style: {
            justifyContent: "flex-start",
            fontWeight: 500,
            fontSize: fontSize.md,
            border: "1px solid transparent",
            padding: `${spacing.xs} ${spacing.xs}`,
            textAlign: "left",
            lineHeight: "1.5",
            borderRadius: radius.lg,
        }, gap: "sm", onClick: async () => {
            if ("balance" in props.token) {
                props.onSelect({
                    tokenAddress: props.token.token_address,
                    chainId: props.token.chain_id,
                });
            }
            else {
                props.onSelect({
                    tokenAddress: props.token.address,
                    chainId: props.token.chainId,
                });
            }
        }, children: [_jsx(Img, { src: ("balance" in props.token
                    ? props.token.icon_uri
                    : props.token.iconUri) || "", client: props.client, width: iconSize.lg, height: iconSize.lg, style: {
                    flexShrink: 0,
                    borderRadius: radius.full,
                }, fallback: _jsx(Container, { color: "secondaryText", children: _jsx(Container, { style: {
                            background: `linear-gradient(45deg, white, ${theme.colors.accentText})`,
                            borderRadius: radius.full,
                            width: `${iconSize.lg}px`,
                            height: `${iconSize.lg}px`,
                        } }) }) }), _jsxs("div", { style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: spacing["3xs"],
                    flex: 1,
                }, children: [_jsxs(Container, { flex: "row", style: {
                            justifyContent: "space-between",
                            width: "100%",
                        }, children: [_jsx(Text, { size: "md", color: "primaryText", weight: 500, children: props.token.symbol }), "balance" in props.token && (_jsx(Text, { size: "md", color: "primaryText", children: tokenAmountFormatter.format(Number(toTokens(BigInt(props.token.balance), props.token.decimals))) }))] }), _jsxs(Container, { flex: "row", style: {
                            justifyContent: "space-between",
                            width: "100%",
                        }, children: [_jsx(Text, { size: "xs", color: "secondaryText", style: {
                                    overflow: "hidden",
                                    textOverflow: "ellipsis",
                                    whiteSpace: "nowrap",
                                    maxWidth: "200px",
                                }, children: props.token.name }), usdValue && (_jsx(Container, { flex: "row", children: _jsxs(Text, { size: "xs", color: "secondaryText", weight: 400, children: ["$", usdValue.toFixed(2)] }) }))] })] })] }));
}
function TokenSelectionScreen(props) {
    const noAllTokensFound = !props.allTokens.isFetching && props.allTokens.data.length === 0;
    const noOwnedTokensFound = !props.ownedTokens.isFetching && props.ownedTokens.data.length === 0;
    const [activeTab, setActiveTab] = useState("all");
    const showSkeletons = (props.allTokens.isFetching && activeTab === "all") ||
        (props.ownedTokens.isFetching && activeTab === "owned");
    const showNoTokensFound = (activeTab === "all" && noAllTokensFound) ||
        (activeTab === "owned" && noOwnedTokensFound);
    const theme = useCustomTheme();
    return (_jsxs(Container, { fullHeight: true, flex: "column", children: [_jsxs(Container, { px: "md", pt: "md+", children: [_jsx(Text, { size: "lg", weight: 600, color: "primaryText", trackingTight: true, children: "Select Token" }), _jsx(Spacer, { y: "3xs" }), _jsx(Text, { size: "sm", color: "secondaryText", multiline: true, style: {
                            textWrap: "pretty",
                        }, children: "Select a token from the list or use the search" })] }), !props.selectedChain && (_jsx("div", { style: {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    minHeight: "300px",
                }, children: _jsx(Spinner, { color: "secondaryText", size: "xl" }) })), props.selectedChain && (_jsxs(_Fragment, { children: [props.isMobile ? (_jsx(Container, { p: "md", children: _jsx(SelectChainButton, { onClick: props.onSelectChain, selectedChain: props.selectedChain, client: props.client }) })) : (_jsx(Spacer, { y: "md" })), _jsx(Container, { px: "md", children: _jsx(SearchInput, { value: props.search, onChange: props.setSearch, placeholder: "Search by token or address", autoFocus: !props.isMobile }) }), _jsx(Spacer, { y: "sm" }), props.isWalletConnected && (_jsxs(Container, { flex: "row", gap: "xs", px: "md", style: { borderBottom: `1px solid ${theme.colors.borderColor}` }, children: [_jsx(TabButton, { isSelected: activeTab === "all", onSelect: () => setActiveTab("all"), label: "All Tokens" }), _jsx(TabButton, { isSelected: activeTab === "owned", onSelect: () => setActiveTab("owned"), label: "Your Tokens" })] })), _jsxs(Container, { pb: "md", px: "md", expand: true, gap: "xxs", flex: "column", style: {
                            minHeight: "300px",
                            maxHeight: props.isMobile ? "450px" : "none",
                            overflowY: "auto",
                            scrollbarWidth: "none",
                            paddingBottom: spacing.md,
                        }, children: [props.isWalletConnected && _jsx(Spacer, { y: "xxs" }), showSkeletons &&
                                new Array(20).fill(0).map((_, i) => (
                                // biome-ignore lint/suspicious/noArrayIndexKey: ok
                                _jsx(TokenButtonSkeleton, {}, i))), activeTab === "owned" &&
                                !props.ownedTokens.isFetching &&
                                props.ownedTokens.data.map((token) => (_jsx(TokenButton, { token: token, client: props.client, onSelect: props.onSelectToken, isSelected: !!props.selectedToken &&
                                        props.selectedToken.tokenAddress.toLowerCase() ===
                                            token.token_address.toLowerCase() &&
                                        token.chain_id === props.selectedToken.chainId }, token.token_address))), activeTab === "all" &&
                                !props.allTokens.isFetching &&
                                props.allTokens.data.map((token) => (_jsx(TokenButton, { token: token, client: props.client, onSelect: props.onSelectToken, isSelected: !!props.selectedToken &&
                                        props.selectedToken.tokenAddress.toLowerCase() ===
                                            token.address.toLowerCase() &&
                                        token.chainId === props.selectedToken.chainId }, token.address))), activeTab === "all" && props.allTokens.showMore && (_jsx(Button, { variant: "secondary", fullWidth: true, onClick: () => {
                                    props.allTokens.showMore?.();
                                }, children: "Load More" })), activeTab === "owned" && props.ownedTokens.showMore && (_jsx(Button, { variant: "secondary", fullWidth: true, onClick: () => {
                                    props.ownedTokens.showMore?.();
                                }, children: "Load More" })), showNoTokensFound && (_jsx("div", { style: {
                                    flex: 1,
                                    display: "flex",
                                    alignItems: "center",
                                    justifyContent: "center",
                                }, children: _jsx(Text, { size: "sm", color: "secondaryText", children: "No Tokens Found" }) }))] })] }))] }));
}
const LeftContainer = /* @__PURE__ */ StyledDiv((_) => {
    const theme = useCustomTheme();
    return {
        display: "flex",
        flexDirection: "column",
        overflowY: "auto",
        ...noScrollBar,
        borderRight: `1px solid ${theme.colors.separatorLine}`,
        position: "relative",
    };
});
function TabButton(props) {
    const theme = useCustomTheme();
    return (_jsxs("div", { style: {
            paddingBottom: "4px",
            position: "relative",
        }, children: [_jsx(Button, { variant: "ghost-solid", onClick: props.onSelect, style: {
                    fontSize: fontSize.sm,
                    padding: `10px ${spacing.xs}`,
                    color: props.isSelected
                        ? theme.colors.primaryText
                        : theme.colors.secondaryText,
                }, children: props.label }), props.isSelected && (_jsx("div", { style: {
                    position: "absolute",
                    left: 0,
                    right: 0,
                    bottom: "-1.5px",
                    borderBottom: `2px solid ${theme.colors.primaryText}`,
                } }))] }));
}
//# sourceMappingURL=select-token-ui.js.map