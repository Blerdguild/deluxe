import { $ as Client$2, A as LiteralTsDsl, B as InitTsDsl, C as SetterTsDsl, D as NotTsDsl, E as ObjectTsDsl, F as TypeExprTsDsl, G as BinaryTsDsl, H as FieldTsDsl, I as TypeAttrTsDsl, J as AwaitTsDsl, K as ReturnTsDsl, L as DecoratorTsDsl, M as GetterTsDsl, N as FuncTsDsl, O as NewlineTsDsl, P as ExprTsDsl, Q as ExpressionTransformer, R as ClassTsDsl, S as TemplateTsDsl, T as PatternTsDsl, U as DescribeTsDsl, V as ParamTsDsl, W as AttrTsDsl, X as TsDsl, Y as ArrayTsDsl, Z as TypeTransformer, _ as VarTsDsl, a as Plugin, b as TypeAliasTsDsl, c as OpenApiOperationObject, d as OpenApiResponseObject, et as PluginHandler, f as OpenApiSchemaObject, g as DollarTsDsl, h as $, i as DefinePlugin, it as MaybeArray, j as IfTsDsl, k as NewTsDsl, l as OpenApiParameterObject, m as Logger, n as UserConfig, nt as IR, o as OpenApi, p as Context, q as CallTsDsl, rt as LazyOrAsync, s as OpenApiMetaObject, tt as StringCase, u as OpenApiRequestBodyObject, v as TypeObjectTsDsl, w as RegExpTsDsl, x as ThrowTsDsl, y as TypeLiteralTsDsl, z as MethodTsDsl } from "./config-CK1EGY2d.cjs";
import { HttpClient, HttpErrorResponse, HttpHeaders, HttpRequest, HttpResponse } from "@angular/common/http";
import { Injector } from "@angular/core";
import { AxiosError, AxiosInstance, AxiosRequestHeaders, AxiosResponse, AxiosStatic, CreateAxiosDefaults } from "axios";
import { AsyncDataOptions, UseFetchOptions, useAsyncData, useFetch, useLazyAsyncData, useLazyFetch } from "nuxt/app";
import { Ref } from "vue";
import { FetchOptions, ResponseType, ofetch } from "ofetch";
import * as typescript34 from "typescript";
import ts from "typescript";

//#region rolldown:runtime
//#endregion
//#region src/plugins/@hey-api/client-core/bundle/auth.d.ts
type AuthToken = string | undefined;
interface Auth {
  /**
   * Which part of the request do we use to send the auth?
   *
   * @default 'header'
   */
  in?: 'header' | 'query' | 'cookie';
  /**
   * Header or query parameter name.
   *
   * @default 'Authorization'
   */
  name?: string;
  scheme?: 'basic' | 'bearer';
  type: 'apiKey' | 'http';
}
//#endregion
//#region src/plugins/@hey-api/client-core/bundle/pathSerializer.d.ts
interface SerializerOptions<T> {
  /**
   * @default true
   */
  explode: boolean;
  style: T;
}
type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';
type ObjectStyle = 'form' | 'deepObject';
//#endregion
//#region src/plugins/@hey-api/client-core/bundle/bodySerializer.d.ts
type QuerySerializer$1 = (query: Record<string, unknown>) => string;
type BodySerializer = (body: any) => any;
type QuerySerializerOptionsObject = {
  allowReserved?: boolean;
  array?: Partial<SerializerOptions<ArrayStyle>>;
  object?: Partial<SerializerOptions<ObjectStyle>>;
};
type QuerySerializerOptions = QuerySerializerOptionsObject & {
  /**
   * Per-parameter serialization overrides. When provided, these settings
   * override the global array/object settings for specific parameter names.
   */
  parameters?: Record<string, QuerySerializerOptionsObject>;
};
//#endregion
//#region src/plugins/@hey-api/client-core/bundle/types.d.ts
type HttpMethod = 'connect' | 'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace';
type Client$7<RequestFn$6 = never, Config$7 = unknown, MethodFn$6 = never, BuildUrlFn$6 = never, SseFn$6 = never> = {
  /**
   * Returns the final request URL.
   */
  buildUrl: BuildUrlFn$6;
  getConfig: () => Config$7;
  request: RequestFn$6;
  setConfig: (config: Config$7) => Config$7;
} & { [K in HttpMethod]: MethodFn$6 } & ([SseFn$6] extends [never] ? {
  sse?: never;
} : {
  sse: { [K in HttpMethod]: SseFn$6 };
});
interface Config {
  /**
   * Auth token or a function returning auth token. The resolved value will be
   * added to the request payload as defined by its `security` array.
   */
  auth?: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken;
  /**
   * A function for serializing request body parameter. By default,
   * {@link JSON.stringify()} will be used.
   */
  bodySerializer?: BodySerializer | null;
  /**
   * An object containing any HTTP headers that you want to pre-populate your
   * `Headers` object with.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/Headers/Headers#init See more}
   */
  headers?: RequestInit['headers'] | Record<string, string | number | boolean | (string | number | boolean)[] | null | undefined | unknown>;
  /**
   * The request method.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/fetch#method See more}
   */
  method?: Uppercase<HttpMethod>;
  /**
   * A function for serializing request query parameters. By default, arrays
   * will be exploded in form style, objects will be exploded in deepObject
   * style, and reserved characters are percent-encoded.
   *
   * This method will have no effect if the native `paramsSerializer()` Axios
   * API function is used.
   *
   * {@link https://swagger.io/docs/specification/serialization/#query View examples}
   */
  querySerializer?: QuerySerializer$1 | QuerySerializerOptions;
  /**
   * A function validating request data. This is useful if you want to ensure
   * the request conforms to the desired shape, so it can be safely sent to
   * the server.
   */
  requestValidator?: (data: unknown) => Promise<unknown>;
  /**
   * A function transforming response data before it's returned. This is useful
   * for post-processing data, e.g. converting ISO strings into Date objects.
   */
  responseTransformer?: (data: unknown) => Promise<unknown>;
  /**
   * A function validating response data. This is useful if you want to ensure
   * the response conforms to the desired shape, so it can be safely passed to
   * the transformers and returned to the user.
   */
  responseValidator?: (data: unknown) => Promise<unknown>;
}
//#endregion
//#region src/plugins/@hey-api/client-core/bundle/serverSentEvents.d.ts
type ServerSentEventsOptions<TData = unknown> = Omit<RequestInit, 'method'> & Pick<Config, 'method' | 'responseTransformer' | 'responseValidator'> & {
  /**
   * Fetch API implementation. You can use this option to provide a custom
   * fetch instance.
   *
   * @default globalThis.fetch
   */
  fetch?: typeof fetch;
  /**
   * Implementing clients can call request interceptors inside this hook.
   */
  onRequest?: (url: string, init: RequestInit) => Promise<Request>;
  /**
   * Callback invoked when a network or parsing error occurs during streaming.
   *
   * This option applies only if the endpoint returns a stream of events.
   *
   * @param error The error that occurred.
   */
  onSseError?: (error: unknown) => void;
  /**
   * Callback invoked when an event is streamed from the server.
   *
   * This option applies only if the endpoint returns a stream of events.
   *
   * @param event Event streamed from the server.
   * @returns Nothing (void).
   */
  onSseEvent?: (event: StreamEvent<TData>) => void;
  serializedBody?: RequestInit['body'];
  /**
   * Default retry delay in milliseconds.
   *
   * This option applies only if the endpoint returns a stream of events.
   *
   * @default 3000
   */
  sseDefaultRetryDelay?: number;
  /**
   * Maximum number of retry attempts before giving up.
   */
  sseMaxRetryAttempts?: number;
  /**
   * Maximum retry delay in milliseconds.
   *
   * Applies only when exponential backoff is used.
   *
   * This option applies only if the endpoint returns a stream of events.
   *
   * @default 30000
   */
  sseMaxRetryDelay?: number;
  /**
   * Optional sleep function for retry backoff.
   *
   * Defaults to using `setTimeout`.
   */
  sseSleepFn?: (ms: number) => Promise<void>;
  url: string;
};
interface StreamEvent<TData = unknown> {
  data: TData;
  event?: string;
  id?: string;
  retry?: number;
}
type ServerSentEventsResult<TData = unknown, TReturn = void, TNext = unknown> = {
  stream: AsyncGenerator<TData extends Record<string, unknown> ? TData[keyof TData] : TData, TReturn, TNext>;
};
//#endregion
//#region src/plugins/@hey-api/client-angular/bundle/utils.d.ts
type ErrInterceptor$3<Err, Res, Req, Options$6> = (error: Err, response: Res, request: Req, options: Options$6) => Err | Promise<Err>;
type ReqInterceptor$3<Req, Options$6> = (request: Req, options: Options$6) => Req | Promise<Req>;
type ResInterceptor$3<Res, Req, Options$6> = (response: Res, request: Req, options: Options$6) => Res | Promise<Res>;
declare class Interceptors$3<Interceptor> {
  fns: Array<Interceptor | null>;
  clear(): void;
  eject(id: number | Interceptor): void;
  exists(id: number | Interceptor): boolean;
  getInterceptorIndex(id: number | Interceptor): number;
  update(id: number | Interceptor, fn: Interceptor): number | Interceptor | false;
  use(fn: Interceptor): number;
}
interface Middleware$3<Req, Res, Err, Options$6> {
  error: Interceptors$3<ErrInterceptor$3<Err, Res, Req, Options$6>>;
  request: Interceptors$3<ReqInterceptor$3<Req, Options$6>>;
  response: Interceptors$3<ResInterceptor$3<Res, Req, Options$6>>;
}
//#endregion
//#region src/plugins/@hey-api/client-angular/bundle/types.d.ts
type ResponseStyle$2 = 'data' | 'fields';
interface Config$6<T extends ClientOptions$5 = ClientOptions$5> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Omit<Config, 'headers'> {
  /**
   * Base URL for all requests made by this client.
   */
  baseUrl?: T['baseUrl'];
  /**
   * An object containing any HTTP headers that you want to pre-populate your
   * `HttpHeaders` object with.
   *
   * {@link https://angular.dev/api/common/http/HttpHeaders#constructor See more}
   */
  headers?: HttpHeaders | Record<string, string | number | boolean | (string | number | boolean)[] | null | undefined | unknown>;
  /**
   * The HTTP client to use for making requests.
   */
  httpClient?: HttpClient;
  /**
   * Should we return only data or multiple fields (data, error, response, etc.)?
   *
   * @default 'fields'
   */
  responseStyle?: ResponseStyle$2;
  /**
   * Throw an error instead of returning it in the response?
   *
   * @default false
   */
  throwOnError?: T['throwOnError'];
}
interface RequestOptions$5<TData = unknown, TResponseStyle extends ResponseStyle$2 = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends Config$6<{
  responseStyle: TResponseStyle;
  throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
  /**
   * Any body that you want to add to your request.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
   */
  body?: unknown;
  /**
   * Optional custom injector for dependency resolution if you don't implicitly or explicitly provide one.
   */
  injector?: Injector;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  /**
   * Security mechanism(s) to use for the request.
   */
  security?: ReadonlyArray<Auth>;
  url: Url;
}
interface ResolvedRequestOptions$3<TResponseStyle extends ResponseStyle$2 = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends RequestOptions$5<unknown, TResponseStyle, ThrowOnError, Url> {
  serializedBody?: string;
}
type RequestResult$5<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean, TResponseStyle extends ResponseStyle$2 = 'fields'> = Promise<ThrowOnError extends true ? TResponseStyle extends 'data' ? TData extends Record<string, unknown> ? TData[keyof TData] : TData : {
  data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
  request: HttpRequest<unknown>;
  response: HttpResponse<TData>;
} : TResponseStyle extends 'data' ? (TData extends Record<string, unknown> ? TData[keyof TData] : TData) | undefined : {
  data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
  error: undefined;
  request: HttpRequest<unknown>;
  response: HttpResponse<TData>;
} | {
  data: undefined;
  error: TError[keyof TError];
  request: HttpRequest<unknown>;
  response: HttpErrorResponse & {
    error: TError[keyof TError] | null;
  };
}>;
interface ClientOptions$5 {
  baseUrl?: string;
  responseStyle?: ResponseStyle$2;
  throwOnError?: boolean;
}
type MethodFn$5 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$2 = 'fields'>(options: Omit<RequestOptions$5<TData, TResponseStyle, ThrowOnError>, 'method'>) => RequestResult$5<TData, TError, ThrowOnError, TResponseStyle>;
type SseFn$5 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$2 = 'fields'>(options: Omit<RequestOptions$5<TData, TResponseStyle, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn$5 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$2 = 'fields'>(options: Omit<RequestOptions$5<TData, TResponseStyle, ThrowOnError>, 'method'> & Pick<Required<RequestOptions$5<TData, TResponseStyle, ThrowOnError>>, 'method'>) => RequestResult$5<TData, TError, ThrowOnError, TResponseStyle>;
type RequestOptionsFn = <ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$2 = 'fields'>(options: RequestOptions$5<unknown, TResponseStyle, ThrowOnError>) => HttpRequest<unknown>;
type BuildUrlFn$5 = <TData extends {
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  url: string;
}>(options: TData & Options$5<TData>) => string;
type Client = Client$7<RequestFn$5, Config$6, MethodFn$5, BuildUrlFn$5, SseFn$5> & {
  interceptors: Middleware$3<HttpRequest<unknown>, HttpResponse<unknown>, unknown, ResolvedRequestOptions$3>;
  requestOptions: RequestOptionsFn;
};
interface TDataShape$5 {
  body?: unknown;
  headers?: unknown;
  path?: unknown;
  query?: unknown;
  url: string;
}
type OmitKeys$5<T, K$1> = Pick<T, Exclude<keyof T, K$1>>;
type Options$5<TData extends TDataShape$5 = TDataShape$5, ThrowOnError extends boolean = boolean, TResponse = unknown, TResponseStyle extends ResponseStyle$2 = 'fields'> = OmitKeys$5<RequestOptions$5<TResponse, TResponseStyle, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & ([TData] extends [never] ? unknown : Omit<TData, 'url'>);
//#endregion
//#region src/plugins/@hey-api/client-axios/bundle/types.d.ts
interface Config$5<T extends ClientOptions$4 = ClientOptions$4> extends Omit<CreateAxiosDefaults, 'auth' | 'baseURL' | 'headers' | 'method'>, Config {
  /**
   * Axios implementation. You can use this option to provide either an
   * `AxiosStatic` or an `AxiosInstance`.
   *
   * @default axios
   */
  axios?: AxiosStatic | AxiosInstance;
  /**
   * Base URL for all requests made by this client.
   */
  baseURL?: T['baseURL'];
  /**
   * An object containing any HTTP headers that you want to pre-populate your
   * `Headers` object with.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/Headers/Headers#init See more}
   */
  headers?: AxiosRequestHeaders | Record<string, string | number | boolean | (string | number | boolean)[] | null | undefined | unknown>;
  /**
   * Throw an error instead of returning it in the response?
   *
   * @default false
   */
  throwOnError?: T['throwOnError'];
}
interface RequestOptions$4<TData = unknown, ThrowOnError extends boolean = boolean, Url extends string = string> extends Config$5<{
  throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
  /**
   * Any body that you want to add to your request.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
   */
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  /**
   * Security mechanism(s) to use for the request.
   */
  security?: ReadonlyArray<Auth>;
  url: Url;
}
interface ClientOptions$4 {
  baseURL?: string;
  throwOnError?: boolean;
}
type RequestResult$4<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean> = ThrowOnError extends true ? Promise<AxiosResponse<TData extends Record<string, unknown> ? TData[keyof TData] : TData>> : Promise<(AxiosResponse<TData extends Record<string, unknown> ? TData[keyof TData] : TData> & {
  error: undefined;
}) | (AxiosError<TError extends Record<string, unknown> ? TError[keyof TError] : TError> & {
  data: undefined;
  error: TError extends Record<string, unknown> ? TError[keyof TError] : TError;
})>;
type MethodFn$4 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$4<TData, ThrowOnError>, 'method'>) => RequestResult$4<TData, TError, ThrowOnError>;
type SseFn$4 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$4<TData, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn$4 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$4<TData, ThrowOnError>, 'method'> & Pick<Required<RequestOptions$4<TData, ThrowOnError>>, 'method'>) => RequestResult$4<TData, TError, ThrowOnError>;
type BuildUrlFn$4 = <TData extends {
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  url: string;
}>(options: TData & Options$4<TData>) => string;
type Client$1 = Client$7<RequestFn$4, Config$5, MethodFn$4, BuildUrlFn$4, SseFn$4> & {
  instance: AxiosInstance;
};
interface TDataShape$4 {
  body?: unknown;
  headers?: unknown;
  path?: unknown;
  query?: unknown;
  url: string;
}
type OmitKeys$4<T, K$1> = Pick<T, Exclude<keyof T, K$1>>;
type Options$4<TData extends TDataShape$4 = TDataShape$4, ThrowOnError extends boolean = boolean, TResponse = unknown> = OmitKeys$4<RequestOptions$4<TResponse, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & ([TData] extends [never] ? unknown : Omit<TData, 'url'>);
//#endregion
//#region src/plugins/@hey-api/client-fetch/bundle/utils.d.ts
type ErrInterceptor$2<Err, Res, Req, Options$6> = (error: Err, response: Res, request: Req, options: Options$6) => Err | Promise<Err>;
type ReqInterceptor$2<Req, Options$6> = (request: Req, options: Options$6) => Req | Promise<Req>;
type ResInterceptor$2<Res, Req, Options$6> = (response: Res, request: Req, options: Options$6) => Res | Promise<Res>;
declare class Interceptors$2<Interceptor> {
  fns: Array<Interceptor | null>;
  clear(): void;
  eject(id: number | Interceptor): void;
  exists(id: number | Interceptor): boolean;
  getInterceptorIndex(id: number | Interceptor): number;
  update(id: number | Interceptor, fn: Interceptor): number | Interceptor | false;
  use(fn: Interceptor): number;
}
interface Middleware$2<Req, Res, Err, Options$6> {
  error: Interceptors$2<ErrInterceptor$2<Err, Res, Req, Options$6>>;
  request: Interceptors$2<ReqInterceptor$2<Req, Options$6>>;
  response: Interceptors$2<ResInterceptor$2<Res, Req, Options$6>>;
}
//#endregion
//#region src/plugins/@hey-api/client-fetch/bundle/types.d.ts
type ResponseStyle$1 = 'data' | 'fields';
interface Config$4<T extends ClientOptions$3 = ClientOptions$3> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Config {
  /**
   * Base URL for all requests made by this client.
   */
  baseUrl?: T['baseUrl'];
  /**
   * Fetch API implementation. You can use this option to provide a custom
   * fetch instance.
   *
   * @default globalThis.fetch
   */
  fetch?: typeof fetch;
  /**
   * Please don't use the Fetch client for Next.js applications. The `next`
   * options won't have any effect.
   *
   * Install {@link https://www.npmjs.com/package/@hey-api/client-next `@hey-api/client-next`} instead.
   */
  next?: never;
  /**
   * Return the response data parsed in a specified format. By default, `auto`
   * will infer the appropriate method from the `Content-Type` response header.
   * You can override this behavior with any of the {@link Body} methods.
   * Select `stream` if you don't want to parse response data at all.
   *
   * @default 'auto'
   */
  parseAs?: 'arrayBuffer' | 'auto' | 'blob' | 'formData' | 'json' | 'stream' | 'text';
  /**
   * Should we return only data or multiple fields (data, error, response, etc.)?
   *
   * @default 'fields'
   */
  responseStyle?: ResponseStyle$1;
  /**
   * Throw an error instead of returning it in the response?
   *
   * @default false
   */
  throwOnError?: T['throwOnError'];
}
interface RequestOptions$3<TData = unknown, TResponseStyle extends ResponseStyle$1 = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends Config$4<{
  responseStyle: TResponseStyle;
  throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
  /**
   * Any body that you want to add to your request.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
   */
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  /**
   * Security mechanism(s) to use for the request.
   */
  security?: ReadonlyArray<Auth>;
  url: Url;
}
interface ResolvedRequestOptions$2<TResponseStyle extends ResponseStyle$1 = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends RequestOptions$3<unknown, TResponseStyle, ThrowOnError, Url> {
  serializedBody?: string;
}
type RequestResult$3<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean, TResponseStyle extends ResponseStyle$1 = 'fields'> = ThrowOnError extends true ? Promise<TResponseStyle extends 'data' ? TData extends Record<string, unknown> ? TData[keyof TData] : TData : {
  data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
  request: Request;
  response: Response;
}> : Promise<TResponseStyle extends 'data' ? (TData extends Record<string, unknown> ? TData[keyof TData] : TData) | undefined : ({
  data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
  error: undefined;
} | {
  data: undefined;
  error: TError extends Record<string, unknown> ? TError[keyof TError] : TError;
}) & {
  request: Request;
  response: Response;
}>;
interface ClientOptions$3 {
  baseUrl?: string;
  responseStyle?: ResponseStyle$1;
  throwOnError?: boolean;
}
type MethodFn$3 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$1 = 'fields'>(options: Omit<RequestOptions$3<TData, TResponseStyle, ThrowOnError>, 'method'>) => RequestResult$3<TData, TError, ThrowOnError, TResponseStyle>;
type SseFn$3 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$1 = 'fields'>(options: Omit<RequestOptions$3<TData, TResponseStyle, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn$3 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$1 = 'fields'>(options: Omit<RequestOptions$3<TData, TResponseStyle, ThrowOnError>, 'method'> & Pick<Required<RequestOptions$3<TData, TResponseStyle, ThrowOnError>>, 'method'>) => RequestResult$3<TData, TError, ThrowOnError, TResponseStyle>;
type BuildUrlFn$3 = <TData extends {
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  url: string;
}>(options: TData & Options$3<TData>) => string;
type Client$3 = Client$7<RequestFn$3, Config$4, MethodFn$3, BuildUrlFn$3, SseFn$3> & {
  interceptors: Middleware$2<Request, Response, unknown, ResolvedRequestOptions$2>;
};
interface TDataShape$3 {
  body?: unknown;
  headers?: unknown;
  path?: unknown;
  query?: unknown;
  url: string;
}
type OmitKeys$3<T, K$1> = Pick<T, Exclude<keyof T, K$1>>;
type Options$3<TData extends TDataShape$3 = TDataShape$3, ThrowOnError extends boolean = boolean, TResponse = unknown, TResponseStyle extends ResponseStyle$1 = 'fields'> = OmitKeys$3<RequestOptions$3<TResponse, TResponseStyle, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & ([TData] extends [never] ? unknown : Omit<TData, 'url'>);
//#endregion
//#region src/plugins/@hey-api/client-next/bundle/utils.d.ts
type ErrInterceptor$1<Err, Res, Options$6> = (error: Err, response: Res, options: Options$6) => Err | Promise<Err>;
type ReqInterceptor$1<Options$6> = (options: Options$6) => void | Promise<void>;
type ResInterceptor$1<Res, Options$6> = (response: Res, options: Options$6) => Res | Promise<Res>;
declare class Interceptors$1<Interceptor> {
  fns: Array<Interceptor | null>;
  clear(): void;
  eject(id: number | Interceptor): void;
  exists(id: number | Interceptor): boolean;
  getInterceptorIndex(id: number | Interceptor): number;
  update(id: number | Interceptor, fn: Interceptor): number | Interceptor | false;
  use(fn: Interceptor): number;
}
interface Middleware$1<Res, Err, Options$6> {
  error: Interceptors$1<ErrInterceptor$1<Err, Res, Options$6>>;
  request: Interceptors$1<ReqInterceptor$1<Options$6>>;
  response: Interceptors$1<ResInterceptor$1<Res, Options$6>>;
}
//#endregion
//#region src/plugins/@hey-api/client-next/bundle/types.d.ts
interface Config$3<T extends ClientOptions$2 = ClientOptions$2> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Config {
  /**
   * Base URL for all requests made by this client.
   */
  baseUrl?: T['baseUrl'];
  /**
   * Fetch API implementation. You can use this option to provide a custom
   * fetch instance.
   *
   * @default globalThis.fetch
   */
  fetch?: typeof fetch;
  /**
   * Return the response data parsed in a specified format. By default, `auto`
   * will infer the appropriate method from the `Content-Type` response header.
   * You can override this behavior with any of the {@link Body} methods.
   * Select `stream` if you don't want to parse response data at all.
   *
   * @default 'auto'
   */
  parseAs?: 'arrayBuffer' | 'auto' | 'blob' | 'formData' | 'json' | 'stream' | 'text';
  /**
   * Throw an error instead of returning it in the response?
   *
   * @default false
   */
  throwOnError?: T['throwOnError'];
}
interface RequestOptions$2<TData = unknown, ThrowOnError extends boolean = boolean, Url extends string = string> extends Config$3<{
  throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
  /**
   * Any body that you want to add to your request.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
   */
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  /**
   * Security mechanism(s) to use for the request.
   */
  security?: ReadonlyArray<Auth>;
  url: Url;
}
interface ResolvedRequestOptions$1<ThrowOnError extends boolean = boolean, Url extends string = string> extends RequestOptions$2<unknown, ThrowOnError, Url> {
  serializedBody?: string;
}
type RequestResult$2<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean> = ThrowOnError extends true ? Promise<{
  data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
  response: Response;
}> : Promise<({
  data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
  error: undefined;
} | {
  data: undefined;
  error: TError extends Record<string, unknown> ? TError[keyof TError] : TError;
}) & {
  response: Response;
}>;
interface ClientOptions$2 {
  baseUrl?: string;
  throwOnError?: boolean;
}
type MethodFn$2 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$2<TData, ThrowOnError>, 'method'>) => RequestResult$2<TData, TError, ThrowOnError>;
type SseFn$2 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$2<TData, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn$2 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$2<TData, ThrowOnError>, 'method'> & Pick<Required<RequestOptions$2<TData, ThrowOnError>>, 'method'>) => RequestResult$2<TData, TError, ThrowOnError>;
type BuildUrlFn$2 = <TData extends {
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  url: string;
}>(options: TData & Options$2<TData>) => string;
type Client$4 = Client$7<RequestFn$2, Config$3, MethodFn$2, BuildUrlFn$2, SseFn$2> & {
  interceptors: Middleware$1<Response, unknown, ResolvedRequestOptions$1>;
};
interface TDataShape$2 {
  body?: unknown;
  headers?: unknown;
  path?: unknown;
  query?: unknown;
  url: string;
}
type OmitKeys$2<T, K$1> = Pick<T, Exclude<keyof T, K$1>>;
type Options$2<TData extends TDataShape$2 = TDataShape$2, ThrowOnError extends boolean = boolean, TResponse = unknown> = OmitKeys$2<RequestOptions$2<TResponse, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & ([TData] extends [never] ? unknown : Omit<TData, 'url'>);
//#endregion
//#region src/plugins/@hey-api/client-nuxt/bundle/types.d.ts
type QuerySerializer = (query: Parameters<Client$5['buildUrl']>[0]['query']) => string;
type WithRefs<TData> = { [K in keyof TData]: NonNullable<TData[K]> extends object ? WithRefs<NonNullable<TData[K]>> | Ref<NonNullable<TData[K]>> : NonNullable<TData[K]> | Ref<NonNullable<TData[K]>> };
type KeysOf<T> = Array<T extends T ? (keyof T extends string ? keyof T : never) : never>;
interface Config$2<T extends ClientOptions$1 = ClientOptions$1> extends Omit<FetchOptions$1<unknown>, 'baseURL' | 'body' | 'headers' | 'method' | 'query'>, WithRefs<Pick<FetchOptions$1<unknown>, 'query'>>, Omit<Config, 'querySerializer'> {
  /**
   * Base URL for all requests made by this client.
   */
  baseURL?: T['baseURL'];
  /**
   * A function for serializing request query parameters. By default, arrays
   * will be exploded in form style, objects will be exploded in deepObject
   * style, and reserved characters are percent-encoded.
   *
   * {@link https://swagger.io/docs/specification/serialization/#query View examples}
   */
  querySerializer?: QuerySerializer | QuerySerializerOptions;
}
interface RequestOptions$1<TComposable extends Composable = '$fetch', ResT = unknown, DefaultT = undefined, Url extends string = string> extends Config$2, WithRefs<{
  /**
   * Any body that you want to add to your request.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
   */
  body?: unknown;
  path?: FetchOptions$1<unknown>['query'];
  query?: FetchOptions$1<unknown>['query'];
  rawBody?: unknown;
}>, Pick<ServerSentEventsOptions<ResT>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
  asyncDataOptions?: AsyncDataOptions<ResT, ResT, KeysOf<ResT>, DefaultT>;
  composable?: TComposable;
  key?: string;
  /**
   * Security mechanism(s) to use for the request.
   */
  security?: ReadonlyArray<Auth>;
  url: Url;
}
type RequestResult$1<TComposable extends Composable, ResT, TError> = TComposable extends '$fetch' ? ReturnType<typeof $fetch<ResT>> : TComposable extends 'useAsyncData' ? ReturnType<typeof useAsyncData<ResT | null, TError>> : TComposable extends 'useFetch' ? ReturnType<typeof useFetch<ResT | null, TError>> : TComposable extends 'useLazyAsyncData' ? ReturnType<typeof useLazyAsyncData<ResT | null, TError>> : TComposable extends 'useLazyFetch' ? ReturnType<typeof useLazyFetch<ResT | null, TError>> : never;
interface ClientOptions$1 {
  baseURL?: string;
}
type MethodFn$1 = <TComposable extends Composable = '$fetch', ResT = unknown, TError = unknown, DefaultT = undefined>(options: Omit<RequestOptions$1<TComposable, ResT, DefaultT>, 'method'>) => RequestResult$1<TComposable, ResT, TError>;
type SseFn$1 = <TComposable extends Composable = '$fetch', ResT = unknown, TError = unknown, DefaultT = undefined>(options: Omit<RequestOptions$1<TComposable, ResT, DefaultT>, 'method'>) => Promise<ServerSentEventsResult<RequestResult$1<TComposable, ResT, TError>>>;
type RequestFn$1 = <TComposable extends Composable = '$fetch', ResT = unknown, TError = unknown, DefaultT = undefined>(options: Omit<RequestOptions$1<TComposable, ResT, DefaultT>, 'method'> & Pick<Required<RequestOptions$1<TComposable, ResT, DefaultT>>, 'method'>) => RequestResult$1<TComposable, ResT, TError>;
/**
 * The `createClientConfig()` function will be called on client initialization
 * and the returned object will become the client's initial configuration.
 *
 * You may want to initialize your client this way instead of calling
 * `setConfig()`. This is useful for example if you're using Next.js
 * to ensure your client always has the correct values.
 */

interface TDataShape$1 {
  body?: unknown;
  headers?: unknown;
  path?: FetchOptions$1<unknown>['query'];
  query?: FetchOptions$1<unknown>['query'];
  url: string;
}
type BuildUrlOptions<TData extends Omit<TDataShape$1, 'headers'> = Omit<TDataShape$1, 'headers'>> = Pick<WithRefs<TData>, 'path' | 'query'> & Pick<TData, 'url'> & Pick<Options$1<'$fetch', TData>, 'baseURL' | 'querySerializer'>;
type BuildUrlFn$1 = <TData extends Omit<TDataShape$1, 'headers'>>(options: BuildUrlOptions<TData>) => string;
type Client$5 = Client$7<RequestFn$1, Config$2, MethodFn$1, BuildUrlFn$1, SseFn$1>;
type OmitKeys$1<T, K$1> = Pick<T, Exclude<keyof T, K$1>>;
type Options$1<TComposable extends Composable = '$fetch', TData extends TDataShape$1 = TDataShape$1, ResT = unknown, DefaultT = undefined> = OmitKeys$1<RequestOptions$1<TComposable, ResT, DefaultT>, 'body' | 'path' | 'query' | 'url'> & ([TData] extends [never] ? unknown : WithRefs<Omit<TData, 'url'>>);
type FetchOptions$1<TData> = Omit<UseFetchOptions<TData, TData>, keyof AsyncDataOptions<TData>>;
type Composable = '$fetch' | 'useAsyncData' | 'useFetch' | 'useLazyAsyncData' | 'useLazyFetch';
//#endregion
//#region src/plugins/@hey-api/client-ofetch/bundle/utils.d.ts
type ErrInterceptor<Err, Res, Req, Options$6> = (error: Err, response: Res, request: Req, options: Options$6) => Err | Promise<Err>;
type ReqInterceptor<Req, Options$6> = (request: Req, options: Options$6) => Req | Promise<Req>;
type ResInterceptor<Res, Req, Options$6> = (response: Res, request: Req, options: Options$6) => Res | Promise<Res>;
declare class Interceptors<Interceptor> {
  fns: Array<Interceptor | null>;
  clear(): void;
  eject(id: number | Interceptor): void;
  exists(id: number | Interceptor): boolean;
  getInterceptorIndex(id: number | Interceptor): number;
  update(id: number | Interceptor, fn: Interceptor): number | Interceptor | false;
  use(fn: Interceptor): number;
}
interface Middleware<Req, Res, Err, Options$6> {
  error: Interceptors<ErrInterceptor<Err, Res, Req, Options$6>>;
  request: Interceptors<ReqInterceptor<Req, Options$6>>;
  response: Interceptors<ResInterceptor<Res, Req, Options$6>>;
}
//#endregion
//#region src/plugins/@hey-api/client-ofetch/bundle/types.d.ts
type ResponseStyle = 'data' | 'fields';
interface Config$1<T extends ClientOptions = ClientOptions> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Config {
  /**
   * HTTP(S) agent configuration (Node.js only). Passed through to ofetch.
   */
  agent?: FetchOptions['agent'];
  /**
   * Base URL for all requests made by this client.
   */
  baseUrl?: T['baseUrl'];
  /**
   * Node-only proxy/agent options.
   */
  dispatcher?: FetchOptions['dispatcher'];
  /**
   * Fetch API implementation. Used for SSE streaming. You can use this option
   * to provide a custom fetch instance.
   *
   * @default globalThis.fetch
   */
  fetch?: typeof fetch;
  /**
   * Controls the native ofetch behaviour that throws `FetchError` when
   * `response.ok === false`. We default to suppressing it to match the fetch
   * client semantics and let `throwOnError` drive the outcome.
   */
  ignoreResponseError?: FetchOptions['ignoreResponseError'];
  /**
   * Please don't use the Fetch client for Next.js applications. The `next`
   * options won't have any effect.
   *
   * Install {@link https://www.npmjs.com/package/@hey-api/client-next `@hey-api/client-next`} instead.
   */
  next?: never;
  /**
   * Custom ofetch instance created via `ofetch.create()`. If provided, it will
   * be used for requests instead of the default `ofetch` export.
   */
  ofetch?: typeof ofetch;
  /**
   * ofetch hook called before a request is sent.
   */
  onRequest?: FetchOptions['onRequest'];
  /**
   * ofetch hook called when a request fails before receiving a response
   * (e.g., network errors or aborted requests).
   */
  onRequestError?: FetchOptions['onRequestError'];
  /**
   * ofetch hook called after a successful response is received and parsed.
   */
  onResponse?: FetchOptions['onResponse'];
  /**
   * ofetch hook called when the response indicates an error (non-ok status)
   * or when response parsing fails.
   */
  onResponseError?: FetchOptions['onResponseError'];
  /**
   * Return the response data parsed in a specified format. By default, `auto`
   * will infer the appropriate method from the `Content-Type` response header.
   * You can override this behavior with any of the {@link Body} methods.
   * Select `stream` if you don't want to parse response data at all.
   *
   * @default 'auto'
   */
  parseAs?: 'arrayBuffer' | 'auto' | 'blob' | 'formData' | 'json' | 'stream' | 'text';
  /** Custom response parser (ofetch). */
  parseResponse?: FetchOptions['parseResponse'];
  /**
   * Should we return only data or multiple fields (data, error, response, etc.)?
   *
   * @default 'fields'
   */
  responseStyle?: ResponseStyle;
  /**
   * ofetch responseType override. If provided, it will be passed directly to
   * ofetch and take precedence over `parseAs`.
   */
  responseType?: ResponseType;
  /**
   * Automatically retry failed requests.
   */
  retry?: FetchOptions['retry'];
  /**
   * Delay (in ms) between retry attempts.
   */
  retryDelay?: FetchOptions['retryDelay'];
  /**
   * HTTP status codes that should trigger a retry.
   */
  retryStatusCodes?: FetchOptions['retryStatusCodes'];
  /**
   * Throw an error instead of returning it in the response?
   *
   * @default false
   */
  throwOnError?: T['throwOnError'];
  /**
   * Abort the request after the given milliseconds.
   */
  timeout?: number;
}
interface RequestOptions<TData = unknown, TResponseStyle extends ResponseStyle = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends Config$1<{
  responseStyle: TResponseStyle;
  throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
  /**
   * Any body that you want to add to your request.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
   */
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  /**
   * Security mechanism(s) to use for the request.
   */
  security?: ReadonlyArray<Auth>;
  url: Url;
}
interface ResolvedRequestOptions<TResponseStyle extends ResponseStyle = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends RequestOptions<unknown, TResponseStyle, ThrowOnError, Url> {
  serializedBody?: string;
}
type RequestResult<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean, TResponseStyle extends ResponseStyle = 'fields'> = ThrowOnError extends true ? Promise<TResponseStyle extends 'data' ? TData extends Record<string, unknown> ? TData[keyof TData] : TData : {
  data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
  request: Request;
  response: Response;
}> : Promise<TResponseStyle extends 'data' ? (TData extends Record<string, unknown> ? TData[keyof TData] : TData) | undefined : ({
  data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
  error: undefined;
} | {
  data: undefined;
  error: TError extends Record<string, unknown> ? TError[keyof TError] : TError;
}) & {
  request: Request;
  response: Response;
}>;
interface ClientOptions {
  baseUrl?: string;
  responseStyle?: ResponseStyle;
  throwOnError?: boolean;
}
type MethodFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'>) => RequestResult<TData, TError, ThrowOnError, TResponseStyle>;
type SseFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'> & Pick<Required<RequestOptions<TData, TResponseStyle, ThrowOnError>>, 'method'>) => RequestResult<TData, TError, ThrowOnError, TResponseStyle>;
type BuildUrlFn = <TData extends {
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  url: string;
}>(options: TData & Options<TData>) => string;
type Client$6 = Client$7<RequestFn, Config$1, MethodFn, BuildUrlFn, SseFn> & {
  interceptors: Middleware<Request, Response, unknown, ResolvedRequestOptions>;
};
interface TDataShape {
  body?: unknown;
  headers?: unknown;
  path?: unknown;
  query?: unknown;
  url: string;
}
type OmitKeys<T, K$1> = Pick<T, Exclude<keyof T, K$1>>;
type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean, TResponse = unknown, TResponseStyle extends ResponseStyle = 'fields'> = OmitKeys<RequestOptions<TResponse, TResponseStyle, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & ([TData] extends [never] ? unknown : Omit<TData, 'url'>);
//#endregion
//#region src/generate.d.ts
/**
 * Generate a client from the provided configuration.
 *
 * @param userConfig User provided {@link UserConfig} configuration(s).
 */
declare const createClient: (userConfig?: LazyOrAsync<MaybeArray<UserConfig>>, logger?: Logger) => Promise<ReadonlyArray<Context>>;
//#endregion
//#region src/config/parser.d.ts
declare const defaultPaginationKeywords: readonly ["after", "before", "cursor", "offset", "page", "start"];
//#endregion
//#region src/config/plugins.d.ts
/**
 * Default plugins used to generate artifacts if plugins aren't specified.
 */
declare const defaultPlugins: readonly ["@hey-api/typescript", "@hey-api/sdk"];
//#endregion
//#region src/plugins/@hey-api/client-core/config.d.ts
declare const clientDefaultConfig: {
  readonly baseUrl: true;
  readonly bundle: true;
  readonly exportFromIndex: false;
};
declare const clientDefaultMeta: {
  readonly dependencies: readonly ["@hey-api/typescript"];
  readonly tags: readonly ["client"];
};
//#endregion
//#region src/plugins/@hey-api/client-core/plugin.d.ts
declare const clientPluginHandler: ({
  plugin
}: Parameters<PluginHandler>[0]) => void;
//#endregion
//#region src/plugins/shared/utils/config.d.ts
declare const definePluginConfig: <T extends Plugin.Types>(defaultConfig: Plugin.Config<T>) => (userConfig?: Omit<T["config"], "name">) => Omit<Plugin.Config<T>, "name"> & {
  /**
   * Cast name to `any` so it doesn't throw type error in `plugins` array.
   * We could allow any `string` as plugin `name` in the object syntax, but
   * that TypeScript trick would cause all string methods to appear as
   * suggested auto completions, which is undesirable.
   */
  name: any;
};
declare namespace types_d_exports {
  export { AccessLevel, FunctionParameter, FunctionTypeParameter, ObjectValue, SyntaxKindKeyword, createAnonymousFunction, createArrayLiteralExpression, createArrowFunction, createAsExpression, createAssignment, createAwaitExpression, createBlock, createConditionalExpression, createEnumDeclaration, createForOfStatement, createFunctionTypeNode, createGetAccessorDeclaration, createIndexedAccessTypeNode, createKeywordTypeNode, createLiteralTypeNode, createMappedTypeNode, createNamespaceDeclaration, createNewExpression, createNull, createObjectType, createParameterDeclaration, createPropertyAccessChain, createPropertyAccessExpression, createPropertyAssignment, createRegularExpressionLiteral, createStringLiteral, createTemplateLiteralType, createTypeAliasDeclaration, createTypeNode, createTypeOfExpression, createTypeOperatorNode, createTypeParameterDeclaration, createTypeParenthesizedNode, createTypeReferenceNode, syntaxKindKeyword, toExpression, toParameterDeclarations, toTypeParameters };
}
type AccessLevel = 'private' | 'protected' | 'public';
type FunctionParameter = {
  accessLevel?: AccessLevel;
  default?: any;
  isReadOnly?: boolean;
  isRequired?: boolean;
  name: string;
  type?: any | ts.TypeNode;
} | {
  destructure: ReadonlyArray<FunctionParameter>;
  type?: any | ts.TypeNode;
};
interface FunctionTypeParameter {
  default?: any;
  extends?: string | ts.TypeNode;
  name: string | ts.Identifier;
}
declare const createTypeNode: (base: any | ts.TypeNode, args?: (any | ts.TypeNode)[]) => ts.TypeNode;
declare const createPropertyAccessChain: ({
  expression,
  name
}: {
  expression: ts.Expression;
  name: string | ts.MemberName;
}) => ts.PropertyAccessChain;
declare const createPropertyAccessExpression: ({
  expression,
  isOptional,
  name
}: {
  expression: string | ts.Expression;
  isOptional?: boolean;
  name: string | number | ts.MemberName;
}) => ts.PropertyAccessChain | ts.PropertyAccessExpression | ts.ElementAccessExpression;
declare const createNull: () => ts.NullLiteral;
/**
 * Convert an unknown value to an expression.
 * @param identifiers - list of keys that are treated as identifiers.
 * @param shorthand - if shorthand syntax is allowed.
 * @param unescape - if string should be unescaped.
 * @param value - the unknown value.
 * @returns ts.Expression
 */
declare const toExpression: <T = unknown>({
  identifiers,
  isValueAccess,
  shorthand,
  unescape,
  value
}: {
  identifiers?: string[];
  isValueAccess?: boolean;
  shorthand?: boolean;
  unescape?: boolean;
  value: T;
}) => ts.Expression | undefined;
/**
 * Convert parameters to the declaration array expected by TypeScript
 * Compiler API.
 * @param parameters - the parameters to convert to declarations
 * @returns ts.ParameterDeclaration[]
 */
declare const toParameterDeclarations: (parameters: ReadonlyArray<FunctionParameter>) => ts.ParameterDeclaration[];
type SyntaxKindKeyword = 'any' | 'async' | 'boolean' | 'export' | 'never' | 'number' | 'private' | 'protected' | 'public' | 'readonly' | 'static' | 'string' | 'undefined' | 'unknown' | 'void';
declare const syntaxKindKeyword: <T extends SyntaxKindKeyword>({
  keyword
}: {
  keyword: T;
}) => T extends "protected" ? ts.SyntaxKind.ProtectedKeyword : T extends "public" ? ts.SyntaxKind.PublicKeyword : T extends "private" ? ts.SyntaxKind.PrivateKeyword : T extends "export" ? ts.SyntaxKind.ExportKeyword : T extends "async" ? ts.SyntaxKind.ExportKeyword : T extends "readonly" ? ts.SyntaxKind.ExportKeyword : T extends "static" ? ts.SyntaxKind.ExportKeyword : ts.SyntaxKind.AnyKeyword | ts.SyntaxKind.BooleanKeyword | ts.SyntaxKind.NeverKeyword | ts.SyntaxKind.NumberKeyword | ts.SyntaxKind.StringKeyword | ts.SyntaxKind.UndefinedKeyword | ts.SyntaxKind.UnknownKeyword | ts.SyntaxKind.VoidKeyword;
declare const createKeywordTypeNode: ({
  keyword
}: {
  keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
}) => ts.KeywordTypeNode<ts.SyntaxKind.VoidKeyword | ts.SyntaxKind.AnyKeyword | ts.SyntaxKind.BooleanKeyword | ts.SyntaxKind.NeverKeyword | ts.SyntaxKind.NumberKeyword | ts.SyntaxKind.StringKeyword | ts.SyntaxKind.UndefinedKeyword | ts.SyntaxKind.UnknownKeyword>;
declare const toTypeParameters: (types: (FunctionTypeParameter | ts.TypeParameterDeclaration)[]) => ts.TypeParameterDeclaration[];
declare const createTypeOperatorNode: ({
  operator,
  type
}: {
  operator: "keyof" | "readonly" | "unique";
  type: ts.TypeNode;
}) => ts.TypeOperatorNode;
declare const createTypeParameterDeclaration: ({
  constraint,
  defaultType,
  modifiers,
  name
}: {
  constraint?: ts.TypeNode;
  defaultType?: ts.TypeNode;
  modifiers?: Array<ts.Modifier>;
  name: string | ts.Identifier;
}) => ts.TypeParameterDeclaration;
declare const createMappedTypeNode: ({
  members,
  nameType,
  questionToken,
  readonlyToken,
  type,
  typeParameter
}: {
  members?: ts.NodeArray<ts.TypeElement>;
  nameType?: ts.TypeNode;
  questionToken?: ts.QuestionToken | ts.PlusToken | ts.MinusToken;
  readonlyToken?: ts.ReadonlyKeyword | ts.PlusToken | ts.MinusToken;
  type?: ts.TypeNode;
  typeParameter: ts.TypeParameterDeclaration;
}) => ts.MappedTypeNode;
declare const createLiteralTypeNode: ({
  literal
}: {
  literal: ts.LiteralTypeNode["literal"];
}) => ts.LiteralTypeNode;
/**
 * Create arrow function type expression.
 */
declare const createArrowFunction: ({
  async,
  comment,
  multiLine,
  parameters,
  returnType,
  statements,
  types
}: {
  async?: boolean;
  comment?: Comments;
  multiLine?: boolean;
  parameters?: ReadonlyArray<FunctionParameter>;
  returnType?: string | ts.TypeNode;
  statements?: ts.Statement[] | ts.Expression;
  types?: FunctionTypeParameter[];
}) => ts.ArrowFunction;
/**
 * Create anonymous function type expression.
 */
declare const createAnonymousFunction: ({
  async,
  comment,
  multiLine,
  parameters,
  returnType,
  statements,
  types
}: {
  async?: boolean;
  comment?: Comments;
  multiLine?: boolean;
  parameters?: FunctionParameter[];
  returnType?: string | ts.TypeNode;
  statements?: ReadonlyArray<ts.Statement>;
  types?: FunctionTypeParameter[];
}) => ts.FunctionExpression;
/**
 * Create Array type expression.
 */
declare const createArrayLiteralExpression: <T>({
  elements,
  multiLine
}: {
  /**
   * The array to create.
   */
  elements: T[];
  /**
   * Should the array be multi line?
   *
   * @default false
   */
  multiLine?: boolean;
}) => ts.ArrayLiteralExpression;
declare const createAwaitExpression: ({
  expression
}: {
  expression: ts.Expression;
}) => ts.AwaitExpression;
declare const createFunctionTypeNode: ({
  parameters,
  returnType,
  typeParameters
}: {
  parameters?: ts.ParameterDeclaration[];
  returnType: ts.TypeNode;
  typeParameters?: ts.TypeParameterDeclaration[];
}) => ts.FunctionTypeNode;
type ObjectValue = {
  assertion?: 'any' | ts.TypeNode;
  comments?: Comments;
  spread: string;
} | {
  comments?: Comments;
  isValueAccess?: boolean;
  key: string;
  shorthand?: boolean;
  value: any;
};
/**
 * Create Object type expression.
 * @param comments - comments to add to each property.
 * @param identifier - keys that should be treated as identifiers.
 * @param multiLine - if the object should be multiline.
 * @param obj - the object to create expression with.
 * @param shorthand - if shorthand syntax should be used.
 * @param unescape - if properties strings should be unescaped.
 * @returns ts.ObjectLiteralExpression
 */
declare const createObjectType: <T extends Record<string, any> | Array<ObjectValue>>({
  comments,
  identifiers,
  multiLine,
  obj,
  shorthand,
  unescape
}: {
  comments?: Comments;
  identifiers?: string[];
  multiLine?: boolean;
  obj: T;
  shorthand?: boolean;
  unescape?: boolean;
}) => ts.ObjectLiteralExpression;
/**
 * Create enum declaration. Example `export enum T = { X, Y };`
 * @param asConst - whether to use const enums.
 * @param comments - comments to add to each property.
 * @param leadingComment - leading comment to add to enum.
 * @param name - the name of the enum.
 * @param obj - the object representing the enum.
 * @returns ts.EnumDeclaration
 */
declare const createEnumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({
  asConst,
  comments: enumMemberComments,
  leadingComment: comments,
  name,
  obj
}: {
  asConst: boolean;
  comments?: Record<string | number, Comments>;
  leadingComment?: Comments;
  name: string | ts.TypeReferenceNode;
  obj: T;
}) => ts.EnumDeclaration;
/**
 * Create namespace declaration. Example `export namespace MyNamespace { ... }`
 * @param name - the name of the namespace.
 * @param nodes - the nodes in the namespace.
 * @returns
 */
declare const createNamespaceDeclaration: ({
  name,
  statements
}: {
  name: string;
  statements: Array<ts.Statement>;
}) => ts.ModuleDeclaration;
declare const createIndexedAccessTypeNode: ({
  indexType,
  objectType
}: {
  indexType: ts.TypeNode;
  objectType: ts.TypeNode;
}) => ts.IndexedAccessTypeNode;
declare const createGetAccessorDeclaration: ({
  modifiers,
  name,
  returnType,
  statements
}: {
  modifiers?: Modifier | ReadonlyArray<Modifier>;
  name: string | ts.PropertyName;
  returnType?: string | ts.Identifier;
  statements: ReadonlyArray<ts.Statement>;
}) => ts.GetAccessorDeclaration;
declare const createStringLiteral: ({
  isSingleQuote,
  text
}: {
  isSingleQuote?: boolean;
  text: string;
}) => ts.StringLiteral;
declare const createConditionalExpression: ({
  condition,
  whenFalse,
  whenTrue
}: {
  condition: ts.Expression;
  whenFalse: ts.Expression;
  whenTrue: ts.Expression;
}) => ts.ConditionalExpression;
declare const createTypeOfExpression: ({
  text
}: {
  text: string | ts.Identifier;
}) => ts.TypeOfExpression;
/**
 * Create a type alias declaration. Example `export type X = Y;`.
 * @param comment (optional) comments to add
 * @param name the name of the type
 * @param type the type
 * @returns ts.TypeAliasDeclaration
 */
declare const createTypeAliasDeclaration: ({
  comment,
  exportType,
  name,
  type,
  typeParameters
}: {
  comment?: Comments;
  exportType?: boolean;
  name: string | ts.TypeReferenceNode;
  type: string | ts.TypeNode | ts.Identifier;
  typeParameters?: FunctionTypeParameter[];
}) => ts.TypeAliasDeclaration;
declare const createTypeReferenceNode: ({
  typeArguments,
  typeName
}: {
  typeArguments?: ts.TypeNode[];
  typeName: string | ts.EntityName;
}) => ts.TypeReferenceNode;
declare const createTypeParenthesizedNode: ({
  type
}: {
  type: ts.TypeNode;
}) => ts.ParenthesizedTypeNode;
declare const createParameterDeclaration: ({
  initializer,
  modifiers,
  name,
  required,
  type
}: {
  initializer?: ts.Expression;
  modifiers?: ReadonlyArray<ts.ModifierLike>;
  name: string | ts.BindingName;
  required?: boolean;
  type?: ts.TypeNode;
}) => ts.ParameterDeclaration;
declare const createNewExpression: ({
  argumentsArray,
  expression,
  typeArguments
}: {
  argumentsArray?: Array<ts.Expression>;
  expression: ts.Expression;
  typeArguments?: Array<ts.TypeNode>;
}) => ts.NewExpression;
declare const createForOfStatement: ({
  awaitModifier,
  expression,
  initializer,
  statement
}: {
  awaitModifier?: ts.AwaitKeyword;
  expression: ts.Expression;
  initializer: ts.ForInitializer;
  statement: ts.Statement;
}) => ts.ForOfStatement;
declare const createAssignment: ({
  left,
  right
}: {
  left: ts.Expression;
  right: ts.Expression;
}) => ts.AssignmentExpression<ts.EqualsToken>;
declare const createBlock: ({
  multiLine,
  statements
}: {
  multiLine?: boolean;
  statements: ReadonlyArray<ts.Statement>;
}) => ts.Block;
declare const createPropertyAssignment: ({
  initializer,
  name
}: {
  initializer: ts.Expression;
  name: string | ts.PropertyName;
}) => ts.PropertyAssignment;
declare const createRegularExpressionLiteral: ({
  flags,
  text
}: {
  flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
  text: string;
}) => ts.RegularExpressionLiteral;
declare const createAsExpression: ({
  expression,
  type
}: {
  expression: ts.Expression;
  type: ts.TypeNode;
}) => ts.AsExpression;
declare const createTemplateLiteralType: ({
  value
}: {
  value: ReadonlyArray<string | ts.TypeNode>;
}) => ts.TemplateLiteralTypeNode;
//#endregion
//#region src/tsc/utils.d.ts
interface ImportExportItemObject<Name extends string | undefined = string | undefined, Alias extends string | undefined = undefined> {
  alias?: Alias;
  asType?: boolean;
  name: Name;
}
/**
 * Print a TypeScript node to a string.
 * @param node the node to print
 * @returns string
 */
declare function tsNodeToString({
  node,
  unescape
}: {
  node: ts.Node;
  unescape?: boolean;
}): string;
type Modifier = AccessLevel | 'async' | 'export' | 'readonly' | 'static';
type CommentLines = Array<string | null | false | undefined>;
type CommentObject = {
  jsdoc?: boolean;
  lines: CommentLines;
};
type Comments = CommentLines | Array<CommentObject>;
declare namespace module_d_exports {
  export { ImportExportItem, createCallExpression, createConstVariable, createExportAllDeclaration, createNamedExportDeclarations, createNamedImportDeclarations };
}
/**
 * Create export all declaration. Example: `export * from './y'`.
 * @param module - module containing exports
 * @returns ts.ExportDeclaration
 */
declare const createExportAllDeclaration: ({
  module,
  shouldAppendJs
}: {
  module: string;
  shouldAppendJs?: boolean;
}) => ts.ExportDeclaration;
type ImportExportItem = ImportExportItemObject | string;
declare const createCallExpression: ({
  functionName,
  parameters,
  types
}: {
  functionName: string | ts.PropertyAccessExpression | ts.PropertyAccessChain | ts.ElementAccessExpression | ts.Expression;
  parameters?: Array<string | ts.Expression | undefined>;
  types?: ReadonlyArray<ts.TypeNode>;
}) => ts.CallExpression;
/**
 * Create a named export declaration. Example: `export { X } from './y'`.
 * @param exports - named imports to export
 * @param module - module containing exports
 * @returns ts.ExportDeclaration
 */
declare const createNamedExportDeclarations: ({
  exports,
  module
}: {
  exports: Array<ImportExportItem> | ImportExportItem;
  module: string;
}) => ts.ExportDeclaration;
/**
 * Create a const variable. Optionally, it can use const assertion or export
 * statement. Example: `export x = {} as const`.
 * @param assertion use const assertion?
 * @param exportConst export created variable?
 * @param expression expression for the variable.
 * @param name name of the variable.
 * @returns ts.VariableStatement
 */
declare const createConstVariable: ({
  assertion,
  comment,
  destructure,
  exportConst,
  expression,
  name,
  typeName
}: {
  assertion?: "const" | ts.TypeNode;
  comment?: Comments;
  destructure?: boolean;
  exportConst?: boolean;
  expression: ts.Expression;
  name: string | ts.TypeReferenceNode;
  typeName?: string | ts.IndexedAccessTypeNode | ts.TypeNode;
}) => ts.VariableStatement;
/**
 * Create a named import declaration. Example: `import { X } from './y'`.
 * @param imports - named exports to import
 * @param module - module containing imports
 * @returns ts.ImportDeclaration
 */
declare const createNamedImportDeclarations: ({
  imports,
  module
}: {
  imports: Array<ImportExportItem> | ImportExportItem;
  module: string;
}) => ts.ImportDeclaration;
//#endregion
//#region src/tsc/typedef.d.ts
type Property = {
  comment?: Comments;
  isReadOnly?: boolean;
  isRequired?: boolean;
  name: string | ts.PropertyName;
  type: any | ts.TypeNode;
};
//#endregion
//#region src/tsc/index.d.ts
declare const tsc: {
  anonymousFunction: ({
    async,
    comment,
    multiLine,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    async?: boolean;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: FunctionParameter[];
    returnType?: string | typescript34.TypeNode;
    statements?: ReadonlyArray<typescript34.Statement>;
    types?: FunctionTypeParameter[];
  }) => typescript34.FunctionExpression;
  arrayLiteralExpression: <T>({
    elements,
    multiLine
  }: {
    elements: T[];
    multiLine?: boolean;
  }) => typescript34.ArrayLiteralExpression;
  arrowFunction: ({
    async,
    comment,
    multiLine,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    async?: boolean;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: ReadonlyArray<FunctionParameter>;
    returnType?: string | typescript34.TypeNode;
    statements?: typescript34.Statement[] | typescript34.Expression;
    types?: FunctionTypeParameter[];
  }) => typescript34.ArrowFunction;
  asExpression: ({
    expression,
    type
  }: {
    expression: typescript34.Expression;
    type: typescript34.TypeNode;
  }) => typescript34.AsExpression;
  assignment: ({
    left,
    right
  }: {
    left: typescript34.Expression;
    right: typescript34.Expression;
  }) => typescript34.AssignmentExpression<typescript34.EqualsToken>;
  awaitExpression: ({
    expression
  }: {
    expression: typescript34.Expression;
  }) => typescript34.AwaitExpression;
  binaryExpression: ({
    left,
    operator,
    right
  }: {
    left: typescript34.Expression;
    operator?: "=" | "===" | "!==" | "in" | "??";
    right: typescript34.Expression | string;
  }) => typescript34.BinaryExpression;
  block: ({
    multiLine,
    statements
  }: {
    multiLine?: boolean;
    statements: ReadonlyArray<typescript34.Statement>;
  }) => typescript34.Block;
  callExpression: ({
    functionName,
    parameters,
    types: types_d_exports
  }: {
    functionName: string | typescript34.PropertyAccessExpression | typescript34.PropertyAccessChain | typescript34.ElementAccessExpression | typescript34.Expression;
    parameters?: Array<string | typescript34.Expression | undefined>;
    types?: ReadonlyArray<typescript34.TypeNode>;
  }) => typescript34.CallExpression;
  classDeclaration: ({
    decorator,
    exportClass,
    extendedClasses,
    name,
    nodes,
    typeParameters
  }: {
    decorator?: {
      args: any[];
      name: string;
    };
    exportClass?: boolean;
    extendedClasses?: ReadonlyArray<string>;
    name: string;
    nodes: ReadonlyArray<typescript34.ClassElement>;
    typeParameters?: ReadonlyArray<typescript34.TypeParameterDeclaration>;
  }) => typescript34.ClassDeclaration;
  conditionalExpression: ({
    condition,
    whenFalse,
    whenTrue
  }: {
    condition: typescript34.Expression;
    whenFalse: typescript34.Expression;
    whenTrue: typescript34.Expression;
  }) => typescript34.ConditionalExpression;
  constVariable: ({
    assertion,
    comment,
    destructure,
    exportConst,
    expression,
    name,
    typeName
  }: {
    assertion?: "const" | typescript34.TypeNode;
    comment?: Comments;
    destructure?: boolean;
    exportConst?: boolean;
    expression: typescript34.Expression;
    name: string | typescript34.TypeReferenceNode;
    typeName?: string | typescript34.IndexedAccessTypeNode | typescript34.TypeNode;
  }) => typescript34.VariableStatement;
  constructorDeclaration: ({
    accessLevel,
    comment,
    multiLine,
    parameters,
    statements
  }: {
    accessLevel?: AccessLevel;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: FunctionParameter[];
    statements?: typescript34.Statement[];
  }) => typescript34.ConstructorDeclaration;
  enumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({
    asConst,
    comments: enumMemberComments,
    leadingComment: comments,
    name,
    obj
  }: {
    asConst: boolean;
    comments?: Record<string | number, Comments>;
    leadingComment?: Comments;
    name: string | typescript34.TypeReferenceNode;
    obj: T;
  }) => typescript34.EnumDeclaration;
  exportAllDeclaration: ({
    module: module_d_exports,
    shouldAppendJs
  }: {
    module: string;
    shouldAppendJs?: boolean;
  }) => typescript34.ExportDeclaration;
  exportNamedDeclaration: ({
    exports,
    module: module_d_exports
  }: {
    exports: Array<ImportExportItem> | ImportExportItem;
    module: string;
  }) => typescript34.ExportDeclaration;
  expressionToStatement: ({
    expression
  }: {
    expression: typescript34.Expression;
  }) => typescript34.ExpressionStatement;
  forOfStatement: ({
    awaitModifier,
    expression,
    initializer,
    statement
  }: {
    awaitModifier?: typescript34.AwaitKeyword;
    expression: typescript34.Expression;
    initializer: typescript34.ForInitializer;
    statement: typescript34.Statement;
  }) => typescript34.ForOfStatement;
  functionTypeNode: ({
    parameters,
    returnType,
    typeParameters
  }: {
    parameters?: typescript34.ParameterDeclaration[];
    returnType: typescript34.TypeNode;
    typeParameters?: typescript34.TypeParameterDeclaration[];
  }) => typescript34.FunctionTypeNode;
  getAccessorDeclaration: ({
    modifiers,
    name,
    returnType,
    statements
  }: {
    modifiers?: Modifier | ReadonlyArray<Modifier>;
    name: string | typescript34.PropertyName;
    returnType?: string | typescript34.Identifier;
    statements: ReadonlyArray<typescript34.Statement>;
  }) => typescript34.GetAccessorDeclaration;
  identifier: (args: string | {
    text: string;
  }) => typescript34.Identifier;
  ifStatement: ({
    elseStatement,
    expression,
    thenStatement
  }: {
    elseStatement?: typescript34.Statement;
    expression: typescript34.Expression;
    thenStatement: typescript34.Statement;
  }) => typescript34.IfStatement;
  indexedAccessTypeNode: ({
    indexType,
    objectType
  }: {
    indexType: typescript34.TypeNode;
    objectType: typescript34.TypeNode;
  }) => typescript34.IndexedAccessTypeNode;
  isTsNode: (node: any) => node is typescript34.Expression;
  keywordTypeNode: ({
    keyword
  }: {
    keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
  }) => typescript34.KeywordTypeNode<typescript34.SyntaxKind.VoidKeyword | typescript34.SyntaxKind.AnyKeyword | typescript34.SyntaxKind.BooleanKeyword | typescript34.SyntaxKind.NeverKeyword | typescript34.SyntaxKind.NumberKeyword | typescript34.SyntaxKind.StringKeyword | typescript34.SyntaxKind.UndefinedKeyword | typescript34.SyntaxKind.UnknownKeyword>;
  literalTypeNode: ({
    literal
  }: {
    literal: typescript34.LiteralTypeNode["literal"];
  }) => typescript34.LiteralTypeNode;
  mappedTypeNode: ({
    members,
    nameType,
    questionToken,
    readonlyToken,
    type,
    typeParameter
  }: {
    members?: typescript34.NodeArray<typescript34.TypeElement>;
    nameType?: typescript34.TypeNode;
    questionToken?: typescript34.QuestionToken | typescript34.PlusToken | typescript34.MinusToken;
    readonlyToken?: typescript34.ReadonlyKeyword | typescript34.PlusToken | typescript34.MinusToken;
    type?: typescript34.TypeNode;
    typeParameter: typescript34.TypeParameterDeclaration;
  }) => typescript34.MappedTypeNode;
  methodDeclaration: ({
    accessLevel,
    comment,
    isStatic,
    multiLine,
    name,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    accessLevel?: AccessLevel;
    comment?: Comments;
    isStatic?: boolean;
    multiLine?: boolean;
    name: string;
    parameters?: ReadonlyArray<FunctionParameter>;
    returnType?: string | typescript34.TypeNode;
    statements?: typescript34.Statement[];
    types?: FunctionTypeParameter[];
  }) => typescript34.MethodDeclaration;
  namedImportDeclarations: ({
    imports,
    module: module_d_exports
  }: {
    imports: Array<ImportExportItem> | ImportExportItem;
    module: string;
  }) => typescript34.ImportDeclaration;
  namespaceDeclaration: ({
    name,
    statements
  }: {
    name: string;
    statements: Array<typescript34.Statement>;
  }) => typescript34.ModuleDeclaration;
  newExpression: ({
    argumentsArray,
    expression,
    typeArguments
  }: {
    argumentsArray?: Array<typescript34.Expression>;
    expression: typescript34.Expression;
    typeArguments?: Array<typescript34.TypeNode>;
  }) => typescript34.NewExpression;
  nodeToString: typeof tsNodeToString;
  null: () => typescript34.NullLiteral;
  objectExpression: <T extends Record<string, any> | Array<ObjectValue>>({
    comments,
    identifiers,
    multiLine,
    obj,
    shorthand,
    unescape
  }: {
    comments?: Comments;
    identifiers?: string[];
    multiLine?: boolean;
    obj: T;
    shorthand?: boolean;
    unescape?: boolean;
  }) => typescript34.ObjectLiteralExpression;
  ots: {
    boolean: (value: boolean) => typescript34.TrueLiteral | typescript34.FalseLiteral;
    export: ({
      alias,
      asType,
      name
    }: ImportExportItemObject) => typescript34.ExportSpecifier;
    import: ({
      alias,
      asType,
      name
    }: ImportExportItemObject) => typescript34.ImportSpecifier;
    number: (value: number) => typescript34.NumericLiteral | typescript34.PrefixUnaryExpression;
    string: (value: string, unescape?: boolean) => typescript34.Identifier | typescript34.StringLiteral;
  };
  parameterDeclaration: ({
    initializer,
    modifiers,
    name,
    required,
    type
  }: {
    initializer?: typescript34.Expression;
    modifiers?: ReadonlyArray<typescript34.ModifierLike>;
    name: string | typescript34.BindingName;
    required?: boolean;
    type?: typescript34.TypeNode;
  }) => typescript34.ParameterDeclaration;
  prefixUnaryExpression: ({
    expression,
    prefix
  }: {
    expression: string | typescript34.Expression;
    prefix: ("-" | "!") | typescript34.PrefixUnaryOperator;
  }) => typescript34.PrefixUnaryExpression;
  propertyAccessExpression: ({
    expression,
    isOptional,
    name
  }: {
    expression: string | typescript34.Expression;
    isOptional?: boolean;
    name: string | number | typescript34.MemberName;
  }) => typescript34.PropertyAccessChain | typescript34.PropertyAccessExpression | typescript34.ElementAccessExpression;
  propertyAccessExpressions: ({
    expressions
  }: {
    expressions: Array<string | typescript34.Expression | typescript34.MemberName>;
  }) => typescript34.PropertyAccessExpression;
  propertyAssignment: ({
    initializer,
    name
  }: {
    initializer: typescript34.Expression;
    name: string | typescript34.PropertyName;
  }) => typescript34.PropertyAssignment;
  propertyDeclaration: ({
    initializer,
    modifiers,
    name,
    type
  }: {
    initializer?: typescript34.Expression;
    modifiers?: Modifier | ReadonlyArray<Modifier>;
    name: string | typescript34.PropertyName;
    type?: typescript34.TypeNode;
  }) => typescript34.PropertyDeclaration;
  regularExpressionLiteral: ({
    flags,
    text
  }: {
    flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
    text: string;
  }) => typescript34.RegularExpressionLiteral;
  returnFunctionCall: ({
    args,
    name,
    types: types_d_exports
  }: {
    args: any[];
    name: string | typescript34.Expression;
    types?: ReadonlyArray<string | typescript34.StringLiteral>;
  }) => typescript34.ReturnStatement;
  returnStatement: ({
    expression
  }: {
    expression?: typescript34.Expression;
  }) => typescript34.ReturnStatement;
  returnVariable: ({
    expression
  }: {
    expression: string | typescript34.Expression;
  }) => typescript34.ReturnStatement;
  safeAccessExpression: (path: string[]) => typescript34.Expression;
  stringLiteral: ({
    isSingleQuote,
    text
  }: {
    isSingleQuote?: boolean;
    text: string;
  }) => typescript34.StringLiteral;
  templateLiteralType: ({
    value
  }: {
    value: ReadonlyArray<string | typescript34.TypeNode>;
  }) => typescript34.TemplateLiteralTypeNode;
  this: () => typescript34.ThisExpression;
  transformArrayMap: ({
    path,
    transformExpression
  }: {
    path: string[];
    transformExpression: typescript34.Expression;
  }) => typescript34.IfStatement;
  transformArrayMutation: ({
    path,
    transformerName
  }: {
    path: string[];
    transformerName: string;
  }) => typescript34.Statement;
  transformDateMutation: ({
    path
  }: {
    path: string[];
  }) => typescript34.Statement;
  transformFunctionMutation: ({
    path,
    transformerName
  }: {
    path: string[];
    transformerName: string;
  }) => typescript34.IfStatement[];
  transformNewDate: ({
    parameterName
  }: {
    parameterName: string;
  }) => typescript34.NewExpression;
  typeAliasDeclaration: ({
    comment,
    exportType,
    name,
    type,
    typeParameters
  }: {
    comment?: Comments;
    exportType?: boolean;
    name: string | typescript34.TypeReferenceNode;
    type: string | typescript34.TypeNode | typescript34.Identifier;
    typeParameters?: FunctionTypeParameter[];
  }) => typescript34.TypeAliasDeclaration;
  typeArrayNode: (types: ReadonlyArray<any | typescript34.TypeNode> | typescript34.TypeNode | typescript34.Identifier | string, isNullable?: boolean) => typescript34.TypeNode;
  typeInterfaceNode: ({
    indexKey,
    indexProperty,
    isNullable,
    properties,
    useLegacyResolution
  }: {
    indexKey?: typescript34.TypeReferenceNode;
    indexProperty?: Property;
    isNullable?: boolean;
    properties: Property[];
    useLegacyResolution: boolean;
  }) => typescript34.TypeNode;
  typeIntersectionNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: (any | typescript34.TypeNode)[];
  }) => typescript34.TypeNode;
  typeNode: (base: any | typescript34.TypeNode, args?: (any | typescript34.TypeNode)[]) => typescript34.TypeNode;
  typeOfExpression: ({
    text
  }: {
    text: string | typescript34.Identifier;
  }) => typescript34.TypeOfExpression;
  typeOperatorNode: ({
    operator,
    type
  }: {
    operator: "keyof" | "readonly" | "unique";
    type: typescript34.TypeNode;
  }) => typescript34.TypeOperatorNode;
  typeParameterDeclaration: ({
    constraint,
    defaultType,
    modifiers,
    name
  }: {
    constraint?: typescript34.TypeNode;
    defaultType?: typescript34.TypeNode;
    modifiers?: Array<typescript34.Modifier>;
    name: string | typescript34.Identifier;
  }) => typescript34.TypeParameterDeclaration;
  typeParenthesizedNode: ({
    type
  }: {
    type: typescript34.TypeNode;
  }) => typescript34.ParenthesizedTypeNode;
  typeRecordNode: (keys: (any | typescript34.TypeNode)[], values: (any | typescript34.TypeNode)[], isNullable?: boolean, useLegacyResolution?: boolean) => typescript34.TypeNode;
  typeReferenceNode: ({
    typeArguments,
    typeName
  }: {
    typeArguments?: typescript34.TypeNode[];
    typeName: string | typescript34.EntityName;
  }) => typescript34.TypeReferenceNode;
  typeTupleNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: Array<any | typescript34.TypeNode>;
  }) => typescript34.TypeNode;
  typeUnionNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: ReadonlyArray<any | typescript34.TypeNode>;
  }) => typescript34.TypeNode;
  valueToExpression: <T = unknown>({
    identifiers,
    isValueAccess,
    shorthand,
    unescape,
    value
  }: {
    identifiers?: string[];
    isValueAccess?: boolean;
    shorthand?: boolean;
    unescape?: boolean;
    value: T;
  }) => typescript34.Expression | undefined;
};
/** @deprecated use tsc */
declare const compiler: {
  anonymousFunction: ({
    async,
    comment,
    multiLine,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    async?: boolean;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: FunctionParameter[];
    returnType?: string | typescript34.TypeNode;
    statements?: ReadonlyArray<typescript34.Statement>;
    types?: FunctionTypeParameter[];
  }) => typescript34.FunctionExpression;
  arrayLiteralExpression: <T>({
    elements,
    multiLine
  }: {
    elements: T[];
    multiLine?: boolean;
  }) => typescript34.ArrayLiteralExpression;
  arrowFunction: ({
    async,
    comment,
    multiLine,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    async?: boolean;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: ReadonlyArray<FunctionParameter>;
    returnType?: string | typescript34.TypeNode;
    statements?: typescript34.Statement[] | typescript34.Expression;
    types?: FunctionTypeParameter[];
  }) => typescript34.ArrowFunction;
  asExpression: ({
    expression,
    type
  }: {
    expression: typescript34.Expression;
    type: typescript34.TypeNode;
  }) => typescript34.AsExpression;
  assignment: ({
    left,
    right
  }: {
    left: typescript34.Expression;
    right: typescript34.Expression;
  }) => typescript34.AssignmentExpression<typescript34.EqualsToken>;
  awaitExpression: ({
    expression
  }: {
    expression: typescript34.Expression;
  }) => typescript34.AwaitExpression;
  binaryExpression: ({
    left,
    operator,
    right
  }: {
    left: typescript34.Expression;
    operator?: "=" | "===" | "!==" | "in" | "??";
    right: typescript34.Expression | string;
  }) => typescript34.BinaryExpression;
  block: ({
    multiLine,
    statements
  }: {
    multiLine?: boolean;
    statements: ReadonlyArray<typescript34.Statement>;
  }) => typescript34.Block;
  callExpression: ({
    functionName,
    parameters,
    types: types_d_exports
  }: {
    functionName: string | typescript34.PropertyAccessExpression | typescript34.PropertyAccessChain | typescript34.ElementAccessExpression | typescript34.Expression;
    parameters?: Array<string | typescript34.Expression | undefined>;
    types?: ReadonlyArray<typescript34.TypeNode>;
  }) => typescript34.CallExpression;
  classDeclaration: ({
    decorator,
    exportClass,
    extendedClasses,
    name,
    nodes,
    typeParameters
  }: {
    decorator?: {
      args: any[];
      name: string;
    };
    exportClass?: boolean;
    extendedClasses?: ReadonlyArray<string>;
    name: string;
    nodes: ReadonlyArray<typescript34.ClassElement>;
    typeParameters?: ReadonlyArray<typescript34.TypeParameterDeclaration>;
  }) => typescript34.ClassDeclaration;
  conditionalExpression: ({
    condition,
    whenFalse,
    whenTrue
  }: {
    condition: typescript34.Expression;
    whenFalse: typescript34.Expression;
    whenTrue: typescript34.Expression;
  }) => typescript34.ConditionalExpression;
  constVariable: ({
    assertion,
    comment,
    destructure,
    exportConst,
    expression,
    name,
    typeName
  }: {
    assertion?: "const" | typescript34.TypeNode;
    comment?: Comments;
    destructure?: boolean;
    exportConst?: boolean;
    expression: typescript34.Expression;
    name: string | typescript34.TypeReferenceNode;
    typeName?: string | typescript34.IndexedAccessTypeNode | typescript34.TypeNode;
  }) => typescript34.VariableStatement;
  constructorDeclaration: ({
    accessLevel,
    comment,
    multiLine,
    parameters,
    statements
  }: {
    accessLevel?: AccessLevel;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: FunctionParameter[];
    statements?: typescript34.Statement[];
  }) => typescript34.ConstructorDeclaration;
  enumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({
    asConst,
    comments: enumMemberComments,
    leadingComment: comments,
    name,
    obj
  }: {
    asConst: boolean;
    comments?: Record<string | number, Comments>;
    leadingComment?: Comments;
    name: string | typescript34.TypeReferenceNode;
    obj: T;
  }) => typescript34.EnumDeclaration;
  exportAllDeclaration: ({
    module: module_d_exports,
    shouldAppendJs
  }: {
    module: string;
    shouldAppendJs?: boolean;
  }) => typescript34.ExportDeclaration;
  exportNamedDeclaration: ({
    exports,
    module: module_d_exports
  }: {
    exports: Array<ImportExportItem> | ImportExportItem;
    module: string;
  }) => typescript34.ExportDeclaration;
  expressionToStatement: ({
    expression
  }: {
    expression: typescript34.Expression;
  }) => typescript34.ExpressionStatement;
  forOfStatement: ({
    awaitModifier,
    expression,
    initializer,
    statement
  }: {
    awaitModifier?: typescript34.AwaitKeyword;
    expression: typescript34.Expression;
    initializer: typescript34.ForInitializer;
    statement: typescript34.Statement;
  }) => typescript34.ForOfStatement;
  functionTypeNode: ({
    parameters,
    returnType,
    typeParameters
  }: {
    parameters?: typescript34.ParameterDeclaration[];
    returnType: typescript34.TypeNode;
    typeParameters?: typescript34.TypeParameterDeclaration[];
  }) => typescript34.FunctionTypeNode;
  getAccessorDeclaration: ({
    modifiers,
    name,
    returnType,
    statements
  }: {
    modifiers?: Modifier | ReadonlyArray<Modifier>;
    name: string | typescript34.PropertyName;
    returnType?: string | typescript34.Identifier;
    statements: ReadonlyArray<typescript34.Statement>;
  }) => typescript34.GetAccessorDeclaration;
  identifier: (args: string | {
    text: string;
  }) => typescript34.Identifier;
  ifStatement: ({
    elseStatement,
    expression,
    thenStatement
  }: {
    elseStatement?: typescript34.Statement;
    expression: typescript34.Expression;
    thenStatement: typescript34.Statement;
  }) => typescript34.IfStatement;
  indexedAccessTypeNode: ({
    indexType,
    objectType
  }: {
    indexType: typescript34.TypeNode;
    objectType: typescript34.TypeNode;
  }) => typescript34.IndexedAccessTypeNode;
  isTsNode: (node: any) => node is typescript34.Expression;
  keywordTypeNode: ({
    keyword
  }: {
    keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
  }) => typescript34.KeywordTypeNode<typescript34.SyntaxKind.VoidKeyword | typescript34.SyntaxKind.AnyKeyword | typescript34.SyntaxKind.BooleanKeyword | typescript34.SyntaxKind.NeverKeyword | typescript34.SyntaxKind.NumberKeyword | typescript34.SyntaxKind.StringKeyword | typescript34.SyntaxKind.UndefinedKeyword | typescript34.SyntaxKind.UnknownKeyword>;
  literalTypeNode: ({
    literal
  }: {
    literal: typescript34.LiteralTypeNode["literal"];
  }) => typescript34.LiteralTypeNode;
  mappedTypeNode: ({
    members,
    nameType,
    questionToken,
    readonlyToken,
    type,
    typeParameter
  }: {
    members?: typescript34.NodeArray<typescript34.TypeElement>;
    nameType?: typescript34.TypeNode;
    questionToken?: typescript34.QuestionToken | typescript34.PlusToken | typescript34.MinusToken;
    readonlyToken?: typescript34.ReadonlyKeyword | typescript34.PlusToken | typescript34.MinusToken;
    type?: typescript34.TypeNode;
    typeParameter: typescript34.TypeParameterDeclaration;
  }) => typescript34.MappedTypeNode;
  methodDeclaration: ({
    accessLevel,
    comment,
    isStatic,
    multiLine,
    name,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    accessLevel?: AccessLevel;
    comment?: Comments;
    isStatic?: boolean;
    multiLine?: boolean;
    name: string;
    parameters?: ReadonlyArray<FunctionParameter>;
    returnType?: string | typescript34.TypeNode;
    statements?: typescript34.Statement[];
    types?: FunctionTypeParameter[];
  }) => typescript34.MethodDeclaration;
  namedImportDeclarations: ({
    imports,
    module: module_d_exports
  }: {
    imports: Array<ImportExportItem> | ImportExportItem;
    module: string;
  }) => typescript34.ImportDeclaration;
  namespaceDeclaration: ({
    name,
    statements
  }: {
    name: string;
    statements: Array<typescript34.Statement>;
  }) => typescript34.ModuleDeclaration;
  newExpression: ({
    argumentsArray,
    expression,
    typeArguments
  }: {
    argumentsArray?: Array<typescript34.Expression>;
    expression: typescript34.Expression;
    typeArguments?: Array<typescript34.TypeNode>;
  }) => typescript34.NewExpression;
  nodeToString: typeof tsNodeToString;
  null: () => typescript34.NullLiteral;
  objectExpression: <T extends Record<string, any> | Array<ObjectValue>>({
    comments,
    identifiers,
    multiLine,
    obj,
    shorthand,
    unescape
  }: {
    comments?: Comments;
    identifiers?: string[];
    multiLine?: boolean;
    obj: T;
    shorthand?: boolean;
    unescape?: boolean;
  }) => typescript34.ObjectLiteralExpression;
  ots: {
    boolean: (value: boolean) => typescript34.TrueLiteral | typescript34.FalseLiteral;
    export: ({
      alias,
      asType,
      name
    }: ImportExportItemObject) => typescript34.ExportSpecifier;
    import: ({
      alias,
      asType,
      name
    }: ImportExportItemObject) => typescript34.ImportSpecifier;
    number: (value: number) => typescript34.NumericLiteral | typescript34.PrefixUnaryExpression;
    string: (value: string, unescape?: boolean) => typescript34.Identifier | typescript34.StringLiteral;
  };
  parameterDeclaration: ({
    initializer,
    modifiers,
    name,
    required,
    type
  }: {
    initializer?: typescript34.Expression;
    modifiers?: ReadonlyArray<typescript34.ModifierLike>;
    name: string | typescript34.BindingName;
    required?: boolean;
    type?: typescript34.TypeNode;
  }) => typescript34.ParameterDeclaration;
  prefixUnaryExpression: ({
    expression,
    prefix
  }: {
    expression: string | typescript34.Expression;
    prefix: ("-" | "!") | typescript34.PrefixUnaryOperator;
  }) => typescript34.PrefixUnaryExpression;
  propertyAccessExpression: ({
    expression,
    isOptional,
    name
  }: {
    expression: string | typescript34.Expression;
    isOptional?: boolean;
    name: string | number | typescript34.MemberName;
  }) => typescript34.PropertyAccessChain | typescript34.PropertyAccessExpression | typescript34.ElementAccessExpression;
  propertyAccessExpressions: ({
    expressions
  }: {
    expressions: Array<string | typescript34.Expression | typescript34.MemberName>;
  }) => typescript34.PropertyAccessExpression;
  propertyAssignment: ({
    initializer,
    name
  }: {
    initializer: typescript34.Expression;
    name: string | typescript34.PropertyName;
  }) => typescript34.PropertyAssignment;
  propertyDeclaration: ({
    initializer,
    modifiers,
    name,
    type
  }: {
    initializer?: typescript34.Expression;
    modifiers?: Modifier | ReadonlyArray<Modifier>;
    name: string | typescript34.PropertyName;
    type?: typescript34.TypeNode;
  }) => typescript34.PropertyDeclaration;
  regularExpressionLiteral: ({
    flags,
    text
  }: {
    flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
    text: string;
  }) => typescript34.RegularExpressionLiteral;
  returnFunctionCall: ({
    args,
    name,
    types: types_d_exports
  }: {
    args: any[];
    name: string | typescript34.Expression;
    types?: ReadonlyArray<string | typescript34.StringLiteral>;
  }) => typescript34.ReturnStatement;
  returnStatement: ({
    expression
  }: {
    expression?: typescript34.Expression;
  }) => typescript34.ReturnStatement;
  returnVariable: ({
    expression
  }: {
    expression: string | typescript34.Expression;
  }) => typescript34.ReturnStatement;
  safeAccessExpression: (path: string[]) => typescript34.Expression;
  stringLiteral: ({
    isSingleQuote,
    text
  }: {
    isSingleQuote?: boolean;
    text: string;
  }) => typescript34.StringLiteral;
  templateLiteralType: ({
    value
  }: {
    value: ReadonlyArray<string | typescript34.TypeNode>;
  }) => typescript34.TemplateLiteralTypeNode;
  this: () => typescript34.ThisExpression;
  transformArrayMap: ({
    path,
    transformExpression
  }: {
    path: string[];
    transformExpression: typescript34.Expression;
  }) => typescript34.IfStatement;
  transformArrayMutation: ({
    path,
    transformerName
  }: {
    path: string[];
    transformerName: string;
  }) => typescript34.Statement;
  transformDateMutation: ({
    path
  }: {
    path: string[];
  }) => typescript34.Statement;
  transformFunctionMutation: ({
    path,
    transformerName
  }: {
    path: string[];
    transformerName: string;
  }) => typescript34.IfStatement[];
  transformNewDate: ({
    parameterName
  }: {
    parameterName: string;
  }) => typescript34.NewExpression;
  typeAliasDeclaration: ({
    comment,
    exportType,
    name,
    type,
    typeParameters
  }: {
    comment?: Comments;
    exportType?: boolean;
    name: string | typescript34.TypeReferenceNode;
    type: string | typescript34.TypeNode | typescript34.Identifier;
    typeParameters?: FunctionTypeParameter[];
  }) => typescript34.TypeAliasDeclaration;
  typeArrayNode: (types: ReadonlyArray<any | typescript34.TypeNode> | typescript34.TypeNode | typescript34.Identifier | string, isNullable?: boolean) => typescript34.TypeNode;
  typeInterfaceNode: ({
    indexKey,
    indexProperty,
    isNullable,
    properties,
    useLegacyResolution
  }: {
    indexKey?: typescript34.TypeReferenceNode;
    indexProperty?: Property;
    isNullable?: boolean;
    properties: Property[];
    useLegacyResolution: boolean;
  }) => typescript34.TypeNode;
  typeIntersectionNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: (any | typescript34.TypeNode)[];
  }) => typescript34.TypeNode;
  typeNode: (base: any | typescript34.TypeNode, args?: (any | typescript34.TypeNode)[]) => typescript34.TypeNode;
  typeOfExpression: ({
    text
  }: {
    text: string | typescript34.Identifier;
  }) => typescript34.TypeOfExpression;
  typeOperatorNode: ({
    operator,
    type
  }: {
    operator: "keyof" | "readonly" | "unique";
    type: typescript34.TypeNode;
  }) => typescript34.TypeOperatorNode;
  typeParameterDeclaration: ({
    constraint,
    defaultType,
    modifiers,
    name
  }: {
    constraint?: typescript34.TypeNode;
    defaultType?: typescript34.TypeNode;
    modifiers?: Array<typescript34.Modifier>;
    name: string | typescript34.Identifier;
  }) => typescript34.TypeParameterDeclaration;
  typeParenthesizedNode: ({
    type
  }: {
    type: typescript34.TypeNode;
  }) => typescript34.ParenthesizedTypeNode;
  typeRecordNode: (keys: (any | typescript34.TypeNode)[], values: (any | typescript34.TypeNode)[], isNullable?: boolean, useLegacyResolution?: boolean) => typescript34.TypeNode;
  typeReferenceNode: ({
    typeArguments,
    typeName
  }: {
    typeArguments?: typescript34.TypeNode[];
    typeName: string | typescript34.EntityName;
  }) => typescript34.TypeReferenceNode;
  typeTupleNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: Array<any | typescript34.TypeNode>;
  }) => typescript34.TypeNode;
  typeUnionNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: ReadonlyArray<any | typescript34.TypeNode>;
  }) => typescript34.TypeNode;
  valueToExpression: <T = unknown>({
    identifiers,
    isValueAccess,
    shorthand,
    unescape,
    value
  }: {
    identifiers?: string[];
    isValueAccess?: boolean;
    shorthand?: boolean;
    unescape?: boolean;
    value: T;
  }) => typescript34.Expression | undefined;
};
//#endregion
//#region src/utils/exports.d.ts
declare const utils: {
  stringCase: ({
    case: _case,
    stripLeadingSeparators,
    value
  }: {
    readonly case: StringCase | undefined;
    stripLeadingSeparators?: boolean;
    value: string;
  }) => string;
};
//#endregion
//#region src/index.d.ts
declare module '@hey-api/codegen-core' {
  interface ProjectRenderMeta {
    /**
     * If specified, this will be the file extension used when importing
     * other modules. By default, we don't add a file extension and let the
     * runtime resolve it.
     *
     * @default null
     */
    importFileExtension?: (string & {}) | null;
  }
  interface SymbolMeta {
    category?: 'client' | 'external' | 'hook' | 'schema' | 'sdk' | 'transform' | 'type' | 'utility' | (string & {});
    /**
     * Path to the resource this symbol represents.
     */
    path?: ReadonlyArray<string | number>;
    /**
     * Name of the plugin that registered this symbol.
     */
    pluginName?: string;
    resource?: 'client' | 'definition' | 'operation' | 'webhook' | (string & {});
    resourceId?: string;
    role?: 'data' | 'error' | 'errors' | 'options' | 'response' | 'responses' | (string & {});
    /**
     * Tags associated with this symbol.
     */
    tags?: ReadonlyArray<string>;
    tool?: 'angular' | 'arktype' | 'fastify' | 'json-schema' | 'sdk' | 'typescript' | 'valibot' | 'zod' | (string & {});
    variant?: 'container' | (string & {});
  }
}
/**
 * Type helper for openapi-ts.config.ts, returns {@link MaybeArray<UserConfig>} object(s)
 */
declare const defineConfig: <T extends MaybeArray<UserConfig>>(config: LazyOrAsync<T>) => Promise<T>;
//#endregion
export { $, type Client as AngularClient, ArrayTsDsl, AttrTsDsl, AwaitTsDsl, type Client$1 as AxiosClient, BinaryTsDsl, CallTsDsl, ClassTsDsl, type Client$2 as Client, DecoratorTsDsl, type DefinePlugin, DescribeTsDsl, DollarTsDsl, ExprTsDsl, type ExpressionTransformer, type Client$3 as FetchClient, FieldTsDsl, FuncTsDsl, GetterTsDsl, type IR, IfTsDsl, InitTsDsl, LiteralTsDsl, Logger, MethodTsDsl, NewTsDsl, NewlineTsDsl, type Client$4 as NextClient, NotTsDsl, type Client$5 as NuxtClient, ObjectTsDsl, type Client$6 as OfetchClient, type OpenApi, type OpenApiMetaObject, type OpenApiOperationObject, type OpenApiParameterObject, type OpenApiRequestBodyObject, type OpenApiResponseObject, type OpenApiSchemaObject, ParamTsDsl, PatternTsDsl, type Plugin, RegExpTsDsl, ReturnTsDsl, SetterTsDsl, TemplateTsDsl, ThrowTsDsl, TsDsl, TypeAliasTsDsl, TypeAttrTsDsl, TypeExprTsDsl, TypeLiteralTsDsl, TypeObjectTsDsl, type TypeTransformer, type UserConfig, VarTsDsl, clientDefaultConfig, clientDefaultMeta, clientPluginHandler, compiler, createClient, defaultPaginationKeywords, defaultPlugins, defineConfig, definePluginConfig, tsc, utils };
//# sourceMappingURL=index.d.cts.map