"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectToken = SelectToken;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const units_js_1 = require("../../../../../utils/units.js");
const CustomThemeProvider_js_1 = require("../../../../core/design-system/CustomThemeProvider.js");
const index_js_1 = require("../../../../core/design-system/index.js");
const basic_js_1 = require("../../components/basic.js");
const buttons_js_1 = require("../../components/buttons.js");
const Img_js_1 = require("../../components/Img.js");
const Skeleton_js_1 = require("../../components/Skeleton.js");
const Spacer_js_1 = require("../../components/Spacer.js");
const Spinner_js_1 = require("../../components/Spinner.js");
const text_js_1 = require("../../components/text.js");
const elements_js_1 = require("../../design-system/elements.js");
const useDebouncedValue_js_1 = require("../../hooks/useDebouncedValue.js");
const useisMobile_js_1 = require("../../hooks/useisMobile.js");
const SearchInput_js_1 = require("./SearchInput.js");
const SelectChainButton_js_1 = require("./SelectChainButton.js");
const select_chain_js_1 = require("./select-chain.js");
const use_bridge_chains_js_1 = require("./use-bridge-chains.js");
const use_tokens_js_1 = require("./use-tokens.js");
const utils_js_1 = require("./utils.js");
function findChain(chains, activeChainId) {
    if (!activeChainId) {
        return undefined;
    }
    return chains.find((chain) => chain.chainId === activeChainId);
}
const ALL_TOKENS_LIMIT = 100;
const OWNED_TOKENS_LIMIT = 50;
/**
 * @internal
 */
function SelectToken(props) {
    const chainQuery = (0, use_bridge_chains_js_1.useBridgeChains)(props.client);
    const [search, _setSearch] = (0, react_1.useState)("");
    const debouncedSearch = (0, useDebouncedValue_js_1.useDebouncedValue)(search, 500);
    const [allTokensLimit, setAllTokensLimit] = (0, react_1.useState)(ALL_TOKENS_LIMIT);
    const [ownedTokensLimit, setOwnedTokensLimit] = (0, react_1.useState)(OWNED_TOKENS_LIMIT);
    const [_selectedChain, setSelectedChain] = (0, react_1.useState)(undefined);
    const selectedChain = _selectedChain ||
        (chainQuery.data
            ? findChain(chainQuery.data, props.selectedToken?.chainId) ||
                findChain(chainQuery.data, props.activeWalletInfo?.activeChain.id) ||
                findChain(chainQuery.data, 1)
            : undefined);
    // all tokens
    const tokensQuery = (0, use_tokens_js_1.useTokens)({
        client: props.client,
        chainId: selectedChain?.chainId,
        search: debouncedSearch,
        limit: allTokensLimit,
        offset: 0,
    });
    // owned tokens
    const ownedTokensQuery = (0, use_tokens_js_1.useTokenBalances)({
        clientId: props.client.clientId,
        chainId: selectedChain?.chainId,
        limit: ownedTokensLimit,
        page: 1,
        walletAddress: props.activeWalletInfo?.activeAccount.address,
    });
    const filteredOwnedTokens = (0, react_1.useMemo)(() => {
        return ownedTokensQuery.data?.tokens?.filter((token) => {
            return (token.symbol.toLowerCase().includes(debouncedSearch.toLowerCase()) ||
                token.name.toLowerCase().includes(debouncedSearch.toLowerCase()) ||
                token.token_address
                    .toLowerCase()
                    .includes(debouncedSearch.toLowerCase()));
        });
    }, [ownedTokensQuery.data?.tokens, debouncedSearch]);
    const setSearch = (0, react_1.useCallback)((search) => {
        _setSearch(search);
        setAllTokensLimit(ALL_TOKENS_LIMIT);
        setOwnedTokensLimit(OWNED_TOKENS_LIMIT);
    }, []);
    return ((0, jsx_runtime_1.jsx)(SelectTokenUI, { ...props, ownedTokens: {
            data: filteredOwnedTokens || [],
            isFetching: ownedTokensQuery.isFetching,
            showMore: ownedTokensQuery.data?.pagination.hasMore
                ? () => {
                    setOwnedTokensLimit(ownedTokensLimit + OWNED_TOKENS_LIMIT);
                }
                : undefined,
        }, allTokens: {
            data: tokensQuery.data || [],
            isFetching: tokensQuery.isFetching,
            showMore: tokensQuery.data?.length === allTokensLimit
                ? () => {
                    setAllTokensLimit(allTokensLimit + ALL_TOKENS_LIMIT);
                }
                : undefined,
        }, selectedChain: selectedChain, setSelectedChain: setSelectedChain, search: search, setSearch: setSearch, selectedToken: props.selectedToken, setSelectedToken: props.setSelectedToken }));
}
function SelectTokenUI(props) {
    const isMobile = (0, useisMobile_js_1.useIsMobile)();
    const [screen, setScreen] = (0, react_1.useState)("select-token");
    // show tokens with icons first
    const sortedOwnedTokens = (0, react_1.useMemo)(() => {
        return props.ownedTokens.data.sort((a, b) => {
            if (a.icon_uri && !b.icon_uri) {
                return -1;
            }
            if (!a.icon_uri && b.icon_uri) {
                return 1;
            }
            return 0;
        });
    }, [props.ownedTokens.data]);
    // show tokens with icons first
    const sortedAllTokens = (0, react_1.useMemo)(() => {
        return props.allTokens.data.sort((a, b) => {
            if (a.iconUri && !b.iconUri) {
                return -1;
            }
            if (!a.iconUri && b.iconUri) {
                return 1;
            }
            return 0;
        });
    }, [props.allTokens.data]);
    // desktop
    if (!isMobile) {
        return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { style: {
                display: "grid",
                gridTemplateColumns: "300px 1fr",
                height: "100%",
            }, children: [(0, jsx_runtime_1.jsx)(LeftContainer, { children: (0, jsx_runtime_1.jsx)(select_chain_js_1.SelectBridgeChain, { onBack: () => setScreen("select-token"), client: props.client, isMobile: false, onSelectChain: (chain) => {
                            props.setSelectedChain(chain);
                            setScreen("select-token");
                        }, selectedChain: props.selectedChain }) }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", relative: true, scrollY: true, children: (0, jsx_runtime_1.jsx)(TokenSelectionScreen, { onSelectToken: (token) => {
                            props.setSelectedToken(token);
                            props.onClose();
                        }, isMobile: false, selectedToken: props.selectedToken, ownedTokens: {
                            ...props.ownedTokens,
                            data: sortedOwnedTokens,
                        }, allTokens: {
                            ...props.allTokens,
                            data: sortedAllTokens,
                        }, selectedChain: props.selectedChain, onSelectChain: () => setScreen("select-chain"), client: props.client, search: props.search, setSearch: props.setSearch, isWalletConnected: props.activeWalletInfo !== undefined }) })] }));
    }
    if (screen === "select-token") {
        return ((0, jsx_runtime_1.jsx)(TokenSelectionScreen, { isWalletConnected: props.activeWalletInfo !== undefined, onSelectToken: (token) => {
                props.setSelectedToken(token);
                props.onClose();
            }, selectedToken: props.selectedToken, ownedTokens: {
                ...props.ownedTokens,
                data: sortedOwnedTokens,
            }, allTokens: {
                ...props.allTokens,
                data: sortedAllTokens,
            }, selectedChain: props.selectedChain, isMobile: true, onSelectChain: () => setScreen("select-chain"), client: props.client, search: props.search, setSearch: props.setSearch }));
    }
    if (screen === "select-chain") {
        return ((0, jsx_runtime_1.jsx)(select_chain_js_1.SelectBridgeChain, { isMobile: true, onBack: () => setScreen("select-token"), client: props.client, onSelectChain: (chain) => {
                props.setSelectedChain(chain);
                setScreen("select-token");
            }, selectedChain: props.selectedChain }));
    }
    return null;
}
function TokenButtonSkeleton() {
    return ((0, jsx_runtime_1.jsxs)("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: index_js_1.spacing.sm,
            padding: `${index_js_1.spacing.xs} ${index_js_1.spacing.xs}`,
            height: "70px",
        }, children: [(0, jsx_runtime_1.jsx)(Skeleton_js_1.Skeleton, { height: `${index_js_1.iconSize.lg}px`, width: `${index_js_1.iconSize.lg}px` }), (0, jsx_runtime_1.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: "4px" }, children: [(0, jsx_runtime_1.jsx)(Skeleton_js_1.Skeleton, { height: index_js_1.fontSize.sm, width: "100px" }), (0, jsx_runtime_1.jsx)(Skeleton_js_1.Skeleton, { height: index_js_1.fontSize.md, width: "200px" })] })] }));
}
function TokenButton(props) {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    const tokenBalanceInUnits = "balance" in props.token
        ? (0, units_js_1.toTokens)(BigInt(props.token.balance), props.token.decimals)
        : undefined;
    const usdValue = "balance" in props.token
        ? props.token.price_data.price_usd * Number(tokenBalanceInUnits)
        : undefined;
    return ((0, jsx_runtime_1.jsxs)(buttons_js_1.Button, { variant: props.isSelected ? "secondary" : "ghost-solid", fullWidth: true, style: {
            justifyContent: "flex-start",
            fontWeight: 500,
            fontSize: index_js_1.fontSize.md,
            border: "1px solid transparent",
            padding: `${index_js_1.spacing.xs} ${index_js_1.spacing.xs}`,
            textAlign: "left",
            lineHeight: "1.5",
            borderRadius: index_js_1.radius.lg,
        }, gap: "sm", onClick: async () => {
            if ("balance" in props.token) {
                props.onSelect({
                    tokenAddress: props.token.token_address,
                    chainId: props.token.chain_id,
                });
            }
            else {
                props.onSelect({
                    tokenAddress: props.token.address,
                    chainId: props.token.chainId,
                });
            }
        }, children: [(0, jsx_runtime_1.jsx)(Img_js_1.Img, { src: ("balance" in props.token
                    ? props.token.icon_uri
                    : props.token.iconUri) || "", client: props.client, width: index_js_1.iconSize.lg, height: index_js_1.iconSize.lg, style: {
                    flexShrink: 0,
                    borderRadius: index_js_1.radius.full,
                }, fallback: (0, jsx_runtime_1.jsx)(basic_js_1.Container, { color: "secondaryText", children: (0, jsx_runtime_1.jsx)(basic_js_1.Container, { style: {
                            background: `linear-gradient(45deg, white, ${theme.colors.accentText})`,
                            borderRadius: index_js_1.radius.full,
                            width: `${index_js_1.iconSize.lg}px`,
                            height: `${index_js_1.iconSize.lg}px`,
                        } }) }) }), (0, jsx_runtime_1.jsxs)("div", { style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: index_js_1.spacing["3xs"],
                    flex: 1,
                }, children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", style: {
                            justifyContent: "space-between",
                            width: "100%",
                        }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "md", color: "primaryText", weight: 500, children: props.token.symbol }), "balance" in props.token && ((0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "md", color: "primaryText", children: utils_js_1.tokenAmountFormatter.format(Number((0, units_js_1.toTokens)(BigInt(props.token.balance), props.token.decimals))) }))] }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", style: {
                            justifyContent: "space-between",
                            width: "100%",
                        }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", color: "secondaryText", style: {
                                    overflow: "hidden",
                                    textOverflow: "ellipsis",
                                    whiteSpace: "nowrap",
                                    maxWidth: "200px",
                                }, children: props.token.name }), usdValue && ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "row", children: (0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "xs", color: "secondaryText", weight: 400, children: ["$", usdValue.toFixed(2)] }) }))] })] })] }));
}
function TokenSelectionScreen(props) {
    const noAllTokensFound = !props.allTokens.isFetching && props.allTokens.data.length === 0;
    const noOwnedTokensFound = !props.ownedTokens.isFetching && props.ownedTokens.data.length === 0;
    const [activeTab, setActiveTab] = (0, react_1.useState)("all");
    const showSkeletons = (props.allTokens.isFetching && activeTab === "all") ||
        (props.ownedTokens.isFetching && activeTab === "owned");
    const showNoTokensFound = (activeTab === "all" && noAllTokensFound) ||
        (activeTab === "owned" && noOwnedTokensFound);
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { fullHeight: true, flex: "column", children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { px: "md", pt: "md+", children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "lg", weight: 600, color: "primaryText", trackingTight: true, children: "Select Token" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "3xs" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "secondaryText", multiline: true, style: {
                            textWrap: "pretty",
                        }, children: "Select a token from the list or use the search" })] }), !props.selectedChain && ((0, jsx_runtime_1.jsx)("div", { style: {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    minHeight: "300px",
                }, children: (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { color: "secondaryText", size: "xl" }) })), props.selectedChain && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [props.isMobile ? ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { p: "md", children: (0, jsx_runtime_1.jsx)(SelectChainButton_js_1.SelectChainButton, { onClick: props.onSelectChain, selectedChain: props.selectedChain, client: props.client }) })) : ((0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { px: "md", children: (0, jsx_runtime_1.jsx)(SearchInput_js_1.SearchInput, { value: props.search, onChange: props.setSearch, placeholder: "Search by token or address", autoFocus: !props.isMobile }) }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), props.isWalletConnected && ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", px: "md", style: { borderBottom: `1px solid ${theme.colors.borderColor}` }, children: [(0, jsx_runtime_1.jsx)(TabButton, { isSelected: activeTab === "all", onSelect: () => setActiveTab("all"), label: "All Tokens" }), (0, jsx_runtime_1.jsx)(TabButton, { isSelected: activeTab === "owned", onSelect: () => setActiveTab("owned"), label: "Your Tokens" })] })), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { pb: "md", px: "md", expand: true, gap: "xxs", flex: "column", style: {
                            minHeight: "300px",
                            maxHeight: props.isMobile ? "450px" : "none",
                            overflowY: "auto",
                            scrollbarWidth: "none",
                            paddingBottom: index_js_1.spacing.md,
                        }, children: [props.isWalletConnected && (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xxs" }), showSkeletons &&
                                new Array(20).fill(0).map((_, i) => (
                                // biome-ignore lint/suspicious/noArrayIndexKey: ok
                                (0, jsx_runtime_1.jsx)(TokenButtonSkeleton, {}, i))), activeTab === "owned" &&
                                !props.ownedTokens.isFetching &&
                                props.ownedTokens.data.map((token) => ((0, jsx_runtime_1.jsx)(TokenButton, { token: token, client: props.client, onSelect: props.onSelectToken, isSelected: !!props.selectedToken &&
                                        props.selectedToken.tokenAddress.toLowerCase() ===
                                            token.token_address.toLowerCase() &&
                                        token.chain_id === props.selectedToken.chainId }, token.token_address))), activeTab === "all" &&
                                !props.allTokens.isFetching &&
                                props.allTokens.data.map((token) => ((0, jsx_runtime_1.jsx)(TokenButton, { token: token, client: props.client, onSelect: props.onSelectToken, isSelected: !!props.selectedToken &&
                                        props.selectedToken.tokenAddress.toLowerCase() ===
                                            token.address.toLowerCase() &&
                                        token.chainId === props.selectedToken.chainId }, token.address))), activeTab === "all" && props.allTokens.showMore && ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "secondary", fullWidth: true, onClick: () => {
                                    props.allTokens.showMore?.();
                                }, children: "Load More" })), activeTab === "owned" && props.ownedTokens.showMore && ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "secondary", fullWidth: true, onClick: () => {
                                    props.ownedTokens.showMore?.();
                                }, children: "Load More" })), showNoTokensFound && ((0, jsx_runtime_1.jsx)("div", { style: {
                                    flex: 1,
                                    display: "flex",
                                    alignItems: "center",
                                    justifyContent: "center",
                                }, children: (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "secondaryText", children: "No Tokens Found" }) }))] })] }))] }));
}
const LeftContainer = /* @__PURE__ */ (0, elements_js_1.StyledDiv)((_) => {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return {
        display: "flex",
        flexDirection: "column",
        overflowY: "auto",
        ...basic_js_1.noScrollBar,
        borderRight: `1px solid ${theme.colors.separatorLine}`,
        position: "relative",
    };
});
function TabButton(props) {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return ((0, jsx_runtime_1.jsxs)("div", { style: {
            paddingBottom: "4px",
            position: "relative",
        }, children: [(0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "ghost-solid", onClick: props.onSelect, style: {
                    fontSize: index_js_1.fontSize.sm,
                    padding: `10px ${index_js_1.spacing.xs}`,
                    color: props.isSelected
                        ? theme.colors.primaryText
                        : theme.colors.secondaryText,
                }, children: props.label }), props.isSelected && ((0, jsx_runtime_1.jsx)("div", { style: {
                    position: "absolute",
                    left: 0,
                    right: 0,
                    bottom: "-1.5px",
                    borderBottom: `2px solid ${theme.colors.primaryText}`,
                } }))] }));
}
//# sourceMappingURL=select-token-ui.js.map