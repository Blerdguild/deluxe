import { $ as Client$2, A as LiteralTsDsl, B as InitTsDsl, C as SetterTsDsl, D as NotTsDsl, E as ObjectTsDsl, F as TypeExprTsDsl, G as BinaryTsDsl, H as FieldTsDsl, I as TypeAttrTsDsl, J as AwaitTsDsl, K as ReturnTsDsl, L as DecoratorTsDsl, M as GetterTsDsl, N as FuncTsDsl, O as NewlineTsDsl, P as ExprTsDsl, Q as ExpressionTransformer, R as ClassTsDsl, S as TemplateTsDsl, T as PatternTsDsl, U as DescribeTsDsl, V as ParamTsDsl, W as AttrTsDsl, X as TsDsl, Y as ArrayTsDsl, Z as TypeTransformer, _ as VarTsDsl, a as Plugin, at as Client$1, b as TypeAliasTsDsl, c as OpenApiOperationObject, ct as IR, d as OpenApiResponseObject, et as PluginHandler, f as OpenApiSchemaObject, g as DollarTsDsl, h as $, i as DefinePlugin, it as Client$3, j as IfTsDsl, k as NewTsDsl, l as OpenApiParameterObject, lt as LazyOrAsync, m as Logger, n as UserConfig, nt as Client$5, o as OpenApi, ot as Client, p as Context, q as CallTsDsl, rt as Client$4, s as OpenApiMetaObject, st as StringCase, tt as Client$6, u as OpenApiRequestBodyObject, ut as MaybeArray, v as TypeObjectTsDsl, w as RegExpTsDsl, x as ThrowTsDsl, y as TypeLiteralTsDsl, z as MethodTsDsl } from "./config-DHUTNwtw.js";
import "@hey-api/codegen-core";
import * as typescript34 from "typescript";
import ts from "typescript";

//#region src/generate.d.ts

/**
 * Generate a client from the provided configuration.
 *
 * @param userConfig User provided {@link UserConfig} configuration(s).
 */
declare const createClient: (userConfig?: LazyOrAsync<MaybeArray<UserConfig>>, logger?: Logger) => Promise<ReadonlyArray<Context>>;
//#endregion
//#region src/config/parser.d.ts
declare const defaultPaginationKeywords: readonly ["after", "before", "cursor", "offset", "page", "start"];
//#endregion
//#region src/config/plugins.d.ts
/**
 * Default plugins used to generate artifacts if plugins aren't specified.
 */
declare const defaultPlugins: readonly ["@hey-api/typescript", "@hey-api/sdk"];
//#endregion
//#region src/plugins/@hey-api/client-core/config.d.ts
declare const clientDefaultConfig: {
  readonly baseUrl: true;
  readonly bundle: true;
  readonly exportFromIndex: false;
};
declare const clientDefaultMeta: {
  readonly dependencies: readonly ["@hey-api/typescript"];
  readonly tags: readonly ["client"];
};
//#endregion
//#region src/plugins/@hey-api/client-core/plugin.d.ts
declare const clientPluginHandler: ({
  plugin
}: Parameters<PluginHandler>[0]) => void;
//#endregion
//#region src/plugins/shared/utils/config.d.ts
declare const definePluginConfig: <T extends Plugin.Types>(defaultConfig: Plugin.Config<T>) => (userConfig?: Omit<T["config"], "name">) => Omit<Plugin.Config<T>, "name"> & {
  /**
   * Cast name to `any` so it doesn't throw type error in `plugins` array.
   * We could allow any `string` as plugin `name` in the object syntax, but
   * that TypeScript trick would cause all string methods to appear as
   * suggested auto completions, which is undesirable.
   */
  name: any;
};
declare namespace types_d_exports {
  export { AccessLevel, FunctionParameter, FunctionTypeParameter, ObjectValue, SyntaxKindKeyword, createAnonymousFunction, createArrayLiteralExpression, createArrowFunction, createAsExpression, createAssignment, createAwaitExpression, createBlock, createConditionalExpression, createEnumDeclaration, createForOfStatement, createFunctionTypeNode, createGetAccessorDeclaration, createIndexedAccessTypeNode, createKeywordTypeNode, createLiteralTypeNode, createMappedTypeNode, createNamespaceDeclaration, createNewExpression, createNull, createObjectType, createParameterDeclaration, createPropertyAccessChain, createPropertyAccessExpression, createPropertyAssignment, createRegularExpressionLiteral, createStringLiteral, createTemplateLiteralType, createTypeAliasDeclaration, createTypeNode, createTypeOfExpression, createTypeOperatorNode, createTypeParameterDeclaration, createTypeParenthesizedNode, createTypeReferenceNode, syntaxKindKeyword, toExpression, toParameterDeclarations, toTypeParameters };
}
type AccessLevel = 'private' | 'protected' | 'public';
type FunctionParameter = {
  accessLevel?: AccessLevel;
  default?: any;
  isReadOnly?: boolean;
  isRequired?: boolean;
  name: string;
  type?: any | ts.TypeNode;
} | {
  destructure: ReadonlyArray<FunctionParameter>;
  type?: any | ts.TypeNode;
};
interface FunctionTypeParameter {
  default?: any;
  extends?: string | ts.TypeNode;
  name: string | ts.Identifier;
}
declare const createTypeNode: (base: any | ts.TypeNode, args?: (any | ts.TypeNode)[]) => ts.TypeNode;
declare const createPropertyAccessChain: ({
  expression,
  name
}: {
  expression: ts.Expression;
  name: string | ts.MemberName;
}) => ts.PropertyAccessChain;
declare const createPropertyAccessExpression: ({
  expression,
  isOptional,
  name
}: {
  expression: string | ts.Expression;
  isOptional?: boolean;
  name: string | number | ts.MemberName;
}) => ts.PropertyAccessChain | ts.PropertyAccessExpression | ts.ElementAccessExpression;
declare const createNull: () => ts.NullLiteral;
/**
 * Convert an unknown value to an expression.
 * @param identifiers - list of keys that are treated as identifiers.
 * @param shorthand - if shorthand syntax is allowed.
 * @param unescape - if string should be unescaped.
 * @param value - the unknown value.
 * @returns ts.Expression
 */
declare const toExpression: <T = unknown>({
  identifiers,
  isValueAccess,
  shorthand,
  unescape,
  value
}: {
  identifiers?: string[];
  isValueAccess?: boolean;
  shorthand?: boolean;
  unescape?: boolean;
  value: T;
}) => ts.Expression | undefined;
/**
 * Convert parameters to the declaration array expected by TypeScript
 * Compiler API.
 * @param parameters - the parameters to convert to declarations
 * @returns ts.ParameterDeclaration[]
 */
declare const toParameterDeclarations: (parameters: ReadonlyArray<FunctionParameter>) => ts.ParameterDeclaration[];
type SyntaxKindKeyword = 'any' | 'async' | 'boolean' | 'export' | 'never' | 'number' | 'private' | 'protected' | 'public' | 'readonly' | 'static' | 'string' | 'undefined' | 'unknown' | 'void';
declare const syntaxKindKeyword: <T extends SyntaxKindKeyword>({
  keyword
}: {
  keyword: T;
}) => T extends "protected" ? ts.SyntaxKind.ProtectedKeyword : T extends "public" ? ts.SyntaxKind.PublicKeyword : T extends "private" ? ts.SyntaxKind.PrivateKeyword : T extends "export" ? ts.SyntaxKind.ExportKeyword : T extends "async" ? ts.SyntaxKind.ExportKeyword : T extends "readonly" ? ts.SyntaxKind.ExportKeyword : T extends "static" ? ts.SyntaxKind.ExportKeyword : ts.SyntaxKind.AnyKeyword | ts.SyntaxKind.BooleanKeyword | ts.SyntaxKind.NeverKeyword | ts.SyntaxKind.NumberKeyword | ts.SyntaxKind.StringKeyword | ts.SyntaxKind.UndefinedKeyword | ts.SyntaxKind.UnknownKeyword | ts.SyntaxKind.VoidKeyword;
declare const createKeywordTypeNode: ({
  keyword
}: {
  keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
}) => ts.KeywordTypeNode<ts.SyntaxKind.VoidKeyword | ts.SyntaxKind.AnyKeyword | ts.SyntaxKind.BooleanKeyword | ts.SyntaxKind.NeverKeyword | ts.SyntaxKind.NumberKeyword | ts.SyntaxKind.StringKeyword | ts.SyntaxKind.UndefinedKeyword | ts.SyntaxKind.UnknownKeyword>;
declare const toTypeParameters: (types: (FunctionTypeParameter | ts.TypeParameterDeclaration)[]) => ts.TypeParameterDeclaration[];
declare const createTypeOperatorNode: ({
  operator,
  type
}: {
  operator: "keyof" | "readonly" | "unique";
  type: ts.TypeNode;
}) => ts.TypeOperatorNode;
declare const createTypeParameterDeclaration: ({
  constraint,
  defaultType,
  modifiers,
  name
}: {
  constraint?: ts.TypeNode;
  defaultType?: ts.TypeNode;
  modifiers?: Array<ts.Modifier>;
  name: string | ts.Identifier;
}) => ts.TypeParameterDeclaration;
declare const createMappedTypeNode: ({
  members,
  nameType,
  questionToken,
  readonlyToken,
  type,
  typeParameter
}: {
  members?: ts.NodeArray<ts.TypeElement>;
  nameType?: ts.TypeNode;
  questionToken?: ts.QuestionToken | ts.PlusToken | ts.MinusToken;
  readonlyToken?: ts.ReadonlyKeyword | ts.PlusToken | ts.MinusToken;
  type?: ts.TypeNode;
  typeParameter: ts.TypeParameterDeclaration;
}) => ts.MappedTypeNode;
declare const createLiteralTypeNode: ({
  literal
}: {
  literal: ts.LiteralTypeNode["literal"];
}) => ts.LiteralTypeNode;
/**
 * Create arrow function type expression.
 */
declare const createArrowFunction: ({
  async,
  comment,
  multiLine,
  parameters,
  returnType,
  statements,
  types
}: {
  async?: boolean;
  comment?: Comments;
  multiLine?: boolean;
  parameters?: ReadonlyArray<FunctionParameter>;
  returnType?: string | ts.TypeNode;
  statements?: ts.Statement[] | ts.Expression;
  types?: FunctionTypeParameter[];
}) => ts.ArrowFunction;
/**
 * Create anonymous function type expression.
 */
declare const createAnonymousFunction: ({
  async,
  comment,
  multiLine,
  parameters,
  returnType,
  statements,
  types
}: {
  async?: boolean;
  comment?: Comments;
  multiLine?: boolean;
  parameters?: FunctionParameter[];
  returnType?: string | ts.TypeNode;
  statements?: ReadonlyArray<ts.Statement>;
  types?: FunctionTypeParameter[];
}) => ts.FunctionExpression;
/**
 * Create Array type expression.
 */
declare const createArrayLiteralExpression: <T>({
  elements,
  multiLine
}: {
  /**
   * The array to create.
   */
  elements: T[];
  /**
   * Should the array be multi line?
   *
   * @default false
   */
  multiLine?: boolean;
}) => ts.ArrayLiteralExpression;
declare const createAwaitExpression: ({
  expression
}: {
  expression: ts.Expression;
}) => ts.AwaitExpression;
declare const createFunctionTypeNode: ({
  parameters,
  returnType,
  typeParameters
}: {
  parameters?: ts.ParameterDeclaration[];
  returnType: ts.TypeNode;
  typeParameters?: ts.TypeParameterDeclaration[];
}) => ts.FunctionTypeNode;
type ObjectValue = {
  assertion?: 'any' | ts.TypeNode;
  comments?: Comments;
  spread: string;
} | {
  comments?: Comments;
  isValueAccess?: boolean;
  key: string;
  shorthand?: boolean;
  value: any;
};
/**
 * Create Object type expression.
 * @param comments - comments to add to each property.
 * @param identifier - keys that should be treated as identifiers.
 * @param multiLine - if the object should be multiline.
 * @param obj - the object to create expression with.
 * @param shorthand - if shorthand syntax should be used.
 * @param unescape - if properties strings should be unescaped.
 * @returns ts.ObjectLiteralExpression
 */
declare const createObjectType: <T extends Record<string, any> | Array<ObjectValue>>({
  comments,
  identifiers,
  multiLine,
  obj,
  shorthand,
  unescape
}: {
  comments?: Comments;
  identifiers?: string[];
  multiLine?: boolean;
  obj: T;
  shorthand?: boolean;
  unescape?: boolean;
}) => ts.ObjectLiteralExpression;
/**
 * Create enum declaration. Example `export enum T = { X, Y };`
 * @param asConst - whether to use const enums.
 * @param comments - comments to add to each property.
 * @param leadingComment - leading comment to add to enum.
 * @param name - the name of the enum.
 * @param obj - the object representing the enum.
 * @returns ts.EnumDeclaration
 */
declare const createEnumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({
  asConst,
  comments: enumMemberComments,
  leadingComment: comments,
  name,
  obj
}: {
  asConst: boolean;
  comments?: Record<string | number, Comments>;
  leadingComment?: Comments;
  name: string | ts.TypeReferenceNode;
  obj: T;
}) => ts.EnumDeclaration;
/**
 * Create namespace declaration. Example `export namespace MyNamespace { ... }`
 * @param name - the name of the namespace.
 * @param nodes - the nodes in the namespace.
 * @returns
 */
declare const createNamespaceDeclaration: ({
  name,
  statements
}: {
  name: string;
  statements: Array<ts.Statement>;
}) => ts.ModuleDeclaration;
declare const createIndexedAccessTypeNode: ({
  indexType,
  objectType
}: {
  indexType: ts.TypeNode;
  objectType: ts.TypeNode;
}) => ts.IndexedAccessTypeNode;
declare const createGetAccessorDeclaration: ({
  modifiers,
  name,
  returnType,
  statements
}: {
  modifiers?: Modifier | ReadonlyArray<Modifier>;
  name: string | ts.PropertyName;
  returnType?: string | ts.Identifier;
  statements: ReadonlyArray<ts.Statement>;
}) => ts.GetAccessorDeclaration;
declare const createStringLiteral: ({
  isSingleQuote,
  text
}: {
  isSingleQuote?: boolean;
  text: string;
}) => ts.StringLiteral;
declare const createConditionalExpression: ({
  condition,
  whenFalse,
  whenTrue
}: {
  condition: ts.Expression;
  whenFalse: ts.Expression;
  whenTrue: ts.Expression;
}) => ts.ConditionalExpression;
declare const createTypeOfExpression: ({
  text
}: {
  text: string | ts.Identifier;
}) => ts.TypeOfExpression;
/**
 * Create a type alias declaration. Example `export type X = Y;`.
 * @param comment (optional) comments to add
 * @param name the name of the type
 * @param type the type
 * @returns ts.TypeAliasDeclaration
 */
declare const createTypeAliasDeclaration: ({
  comment,
  exportType,
  name,
  type,
  typeParameters
}: {
  comment?: Comments;
  exportType?: boolean;
  name: string | ts.TypeReferenceNode;
  type: string | ts.TypeNode | ts.Identifier;
  typeParameters?: FunctionTypeParameter[];
}) => ts.TypeAliasDeclaration;
declare const createTypeReferenceNode: ({
  typeArguments,
  typeName
}: {
  typeArguments?: ts.TypeNode[];
  typeName: string | ts.EntityName;
}) => ts.TypeReferenceNode;
declare const createTypeParenthesizedNode: ({
  type
}: {
  type: ts.TypeNode;
}) => ts.ParenthesizedTypeNode;
declare const createParameterDeclaration: ({
  initializer,
  modifiers,
  name,
  required,
  type
}: {
  initializer?: ts.Expression;
  modifiers?: ReadonlyArray<ts.ModifierLike>;
  name: string | ts.BindingName;
  required?: boolean;
  type?: ts.TypeNode;
}) => ts.ParameterDeclaration;
declare const createNewExpression: ({
  argumentsArray,
  expression,
  typeArguments
}: {
  argumentsArray?: Array<ts.Expression>;
  expression: ts.Expression;
  typeArguments?: Array<ts.TypeNode>;
}) => ts.NewExpression;
declare const createForOfStatement: ({
  awaitModifier,
  expression,
  initializer,
  statement
}: {
  awaitModifier?: ts.AwaitKeyword;
  expression: ts.Expression;
  initializer: ts.ForInitializer;
  statement: ts.Statement;
}) => ts.ForOfStatement;
declare const createAssignment: ({
  left,
  right
}: {
  left: ts.Expression;
  right: ts.Expression;
}) => ts.AssignmentExpression<ts.EqualsToken>;
declare const createBlock: ({
  multiLine,
  statements
}: {
  multiLine?: boolean;
  statements: ReadonlyArray<ts.Statement>;
}) => ts.Block;
declare const createPropertyAssignment: ({
  initializer,
  name
}: {
  initializer: ts.Expression;
  name: string | ts.PropertyName;
}) => ts.PropertyAssignment;
declare const createRegularExpressionLiteral: ({
  flags,
  text
}: {
  flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
  text: string;
}) => ts.RegularExpressionLiteral;
declare const createAsExpression: ({
  expression,
  type
}: {
  expression: ts.Expression;
  type: ts.TypeNode;
}) => ts.AsExpression;
declare const createTemplateLiteralType: ({
  value
}: {
  value: ReadonlyArray<string | ts.TypeNode>;
}) => ts.TemplateLiteralTypeNode;
//#endregion
//#region src/tsc/utils.d.ts
interface ImportExportItemObject<Name extends string | undefined = string | undefined, Alias extends string | undefined = undefined> {
  alias?: Alias;
  asType?: boolean;
  name: Name;
}
/**
 * Print a TypeScript node to a string.
 * @param node the node to print
 * @returns string
 */
declare function tsNodeToString({
  node,
  unescape
}: {
  node: ts.Node;
  unescape?: boolean;
}): string;
type Modifier = AccessLevel | 'async' | 'export' | 'readonly' | 'static';
type CommentLines = Array<string | null | false | undefined>;
type CommentObject = {
  jsdoc?: boolean;
  lines: CommentLines;
};
type Comments = CommentLines | Array<CommentObject>;
declare namespace module_d_exports {
  export { ImportExportItem, createCallExpression, createConstVariable, createExportAllDeclaration, createNamedExportDeclarations, createNamedImportDeclarations };
}
/**
 * Create export all declaration. Example: `export * from './y'`.
 * @param module - module containing exports
 * @returns ts.ExportDeclaration
 */
declare const createExportAllDeclaration: ({
  module,
  shouldAppendJs
}: {
  module: string;
  shouldAppendJs?: boolean;
}) => ts.ExportDeclaration;
type ImportExportItem = ImportExportItemObject | string;
declare const createCallExpression: ({
  functionName,
  parameters,
  types
}: {
  functionName: string | ts.PropertyAccessExpression | ts.PropertyAccessChain | ts.ElementAccessExpression | ts.Expression;
  parameters?: Array<string | ts.Expression | undefined>;
  types?: ReadonlyArray<ts.TypeNode>;
}) => ts.CallExpression;
/**
 * Create a named export declaration. Example: `export { X } from './y'`.
 * @param exports - named imports to export
 * @param module - module containing exports
 * @returns ts.ExportDeclaration
 */
declare const createNamedExportDeclarations: ({
  exports,
  module
}: {
  exports: Array<ImportExportItem> | ImportExportItem;
  module: string;
}) => ts.ExportDeclaration;
/**
 * Create a const variable. Optionally, it can use const assertion or export
 * statement. Example: `export x = {} as const`.
 * @param assertion use const assertion?
 * @param exportConst export created variable?
 * @param expression expression for the variable.
 * @param name name of the variable.
 * @returns ts.VariableStatement
 */
declare const createConstVariable: ({
  assertion,
  comment,
  destructure,
  exportConst,
  expression,
  name,
  typeName
}: {
  assertion?: "const" | ts.TypeNode;
  comment?: Comments;
  destructure?: boolean;
  exportConst?: boolean;
  expression: ts.Expression;
  name: string | ts.TypeReferenceNode;
  typeName?: string | ts.IndexedAccessTypeNode | ts.TypeNode;
}) => ts.VariableStatement;
/**
 * Create a named import declaration. Example: `import { X } from './y'`.
 * @param imports - named exports to import
 * @param module - module containing imports
 * @returns ts.ImportDeclaration
 */
declare const createNamedImportDeclarations: ({
  imports,
  module
}: {
  imports: Array<ImportExportItem> | ImportExportItem;
  module: string;
}) => ts.ImportDeclaration;
//#endregion
//#region src/tsc/typedef.d.ts
type Property = {
  comment?: Comments;
  isReadOnly?: boolean;
  isRequired?: boolean;
  name: string | ts.PropertyName;
  type: any | ts.TypeNode;
};
//#endregion
//#region src/tsc/index.d.ts
declare const tsc: {
  anonymousFunction: ({
    async,
    comment,
    multiLine,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    async?: boolean;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: FunctionParameter[];
    returnType?: string | typescript34.TypeNode;
    statements?: ReadonlyArray<typescript34.Statement>;
    types?: FunctionTypeParameter[];
  }) => typescript34.FunctionExpression;
  arrayLiteralExpression: <T>({
    elements,
    multiLine
  }: {
    elements: T[];
    multiLine?: boolean;
  }) => typescript34.ArrayLiteralExpression;
  arrowFunction: ({
    async,
    comment,
    multiLine,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    async?: boolean;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: ReadonlyArray<FunctionParameter>;
    returnType?: string | typescript34.TypeNode;
    statements?: typescript34.Statement[] | typescript34.Expression;
    types?: FunctionTypeParameter[];
  }) => typescript34.ArrowFunction;
  asExpression: ({
    expression,
    type
  }: {
    expression: typescript34.Expression;
    type: typescript34.TypeNode;
  }) => typescript34.AsExpression;
  assignment: ({
    left,
    right
  }: {
    left: typescript34.Expression;
    right: typescript34.Expression;
  }) => typescript34.AssignmentExpression<typescript34.EqualsToken>;
  awaitExpression: ({
    expression
  }: {
    expression: typescript34.Expression;
  }) => typescript34.AwaitExpression;
  binaryExpression: ({
    left,
    operator,
    right
  }: {
    left: typescript34.Expression;
    operator?: "=" | "===" | "!==" | "in" | "??";
    right: typescript34.Expression | string;
  }) => typescript34.BinaryExpression;
  block: ({
    multiLine,
    statements
  }: {
    multiLine?: boolean;
    statements: ReadonlyArray<typescript34.Statement>;
  }) => typescript34.Block;
  callExpression: ({
    functionName,
    parameters,
    types: types_d_exports
  }: {
    functionName: string | typescript34.PropertyAccessExpression | typescript34.PropertyAccessChain | typescript34.ElementAccessExpression | typescript34.Expression;
    parameters?: Array<string | typescript34.Expression | undefined>;
    types?: ReadonlyArray<typescript34.TypeNode>;
  }) => typescript34.CallExpression;
  classDeclaration: ({
    decorator,
    exportClass,
    extendedClasses,
    name,
    nodes,
    typeParameters
  }: {
    decorator?: {
      args: any[];
      name: string;
    };
    exportClass?: boolean;
    extendedClasses?: ReadonlyArray<string>;
    name: string;
    nodes: ReadonlyArray<typescript34.ClassElement>;
    typeParameters?: ReadonlyArray<typescript34.TypeParameterDeclaration>;
  }) => typescript34.ClassDeclaration;
  conditionalExpression: ({
    condition,
    whenFalse,
    whenTrue
  }: {
    condition: typescript34.Expression;
    whenFalse: typescript34.Expression;
    whenTrue: typescript34.Expression;
  }) => typescript34.ConditionalExpression;
  constVariable: ({
    assertion,
    comment,
    destructure,
    exportConst,
    expression,
    name,
    typeName
  }: {
    assertion?: "const" | typescript34.TypeNode;
    comment?: Comments;
    destructure?: boolean;
    exportConst?: boolean;
    expression: typescript34.Expression;
    name: string | typescript34.TypeReferenceNode;
    typeName?: string | typescript34.IndexedAccessTypeNode | typescript34.TypeNode;
  }) => typescript34.VariableStatement;
  constructorDeclaration: ({
    accessLevel,
    comment,
    multiLine,
    parameters,
    statements
  }: {
    accessLevel?: AccessLevel;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: FunctionParameter[];
    statements?: typescript34.Statement[];
  }) => typescript34.ConstructorDeclaration;
  enumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({
    asConst,
    comments: enumMemberComments,
    leadingComment: comments,
    name,
    obj
  }: {
    asConst: boolean;
    comments?: Record<string | number, Comments>;
    leadingComment?: Comments;
    name: string | typescript34.TypeReferenceNode;
    obj: T;
  }) => typescript34.EnumDeclaration;
  exportAllDeclaration: ({
    module: module_d_exports,
    shouldAppendJs
  }: {
    module: string;
    shouldAppendJs?: boolean;
  }) => typescript34.ExportDeclaration;
  exportNamedDeclaration: ({
    exports,
    module: module_d_exports
  }: {
    exports: Array<ImportExportItem> | ImportExportItem;
    module: string;
  }) => typescript34.ExportDeclaration;
  expressionToStatement: ({
    expression
  }: {
    expression: typescript34.Expression;
  }) => typescript34.ExpressionStatement;
  forOfStatement: ({
    awaitModifier,
    expression,
    initializer,
    statement
  }: {
    awaitModifier?: typescript34.AwaitKeyword;
    expression: typescript34.Expression;
    initializer: typescript34.ForInitializer;
    statement: typescript34.Statement;
  }) => typescript34.ForOfStatement;
  functionTypeNode: ({
    parameters,
    returnType,
    typeParameters
  }: {
    parameters?: typescript34.ParameterDeclaration[];
    returnType: typescript34.TypeNode;
    typeParameters?: typescript34.TypeParameterDeclaration[];
  }) => typescript34.FunctionTypeNode;
  getAccessorDeclaration: ({
    modifiers,
    name,
    returnType,
    statements
  }: {
    modifiers?: Modifier | ReadonlyArray<Modifier>;
    name: string | typescript34.PropertyName;
    returnType?: string | typescript34.Identifier;
    statements: ReadonlyArray<typescript34.Statement>;
  }) => typescript34.GetAccessorDeclaration;
  identifier: (args: string | {
    text: string;
  }) => typescript34.Identifier;
  ifStatement: ({
    elseStatement,
    expression,
    thenStatement
  }: {
    elseStatement?: typescript34.Statement;
    expression: typescript34.Expression;
    thenStatement: typescript34.Statement;
  }) => typescript34.IfStatement;
  indexedAccessTypeNode: ({
    indexType,
    objectType
  }: {
    indexType: typescript34.TypeNode;
    objectType: typescript34.TypeNode;
  }) => typescript34.IndexedAccessTypeNode;
  isTsNode: (node: any) => node is typescript34.Expression;
  keywordTypeNode: ({
    keyword
  }: {
    keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
  }) => typescript34.KeywordTypeNode<typescript34.SyntaxKind.VoidKeyword | typescript34.SyntaxKind.AnyKeyword | typescript34.SyntaxKind.BooleanKeyword | typescript34.SyntaxKind.NeverKeyword | typescript34.SyntaxKind.NumberKeyword | typescript34.SyntaxKind.StringKeyword | typescript34.SyntaxKind.UndefinedKeyword | typescript34.SyntaxKind.UnknownKeyword>;
  literalTypeNode: ({
    literal
  }: {
    literal: typescript34.LiteralTypeNode["literal"];
  }) => typescript34.LiteralTypeNode;
  mappedTypeNode: ({
    members,
    nameType,
    questionToken,
    readonlyToken,
    type,
    typeParameter
  }: {
    members?: typescript34.NodeArray<typescript34.TypeElement>;
    nameType?: typescript34.TypeNode;
    questionToken?: typescript34.QuestionToken | typescript34.PlusToken | typescript34.MinusToken;
    readonlyToken?: typescript34.ReadonlyKeyword | typescript34.PlusToken | typescript34.MinusToken;
    type?: typescript34.TypeNode;
    typeParameter: typescript34.TypeParameterDeclaration;
  }) => typescript34.MappedTypeNode;
  methodDeclaration: ({
    accessLevel,
    comment,
    isStatic,
    multiLine,
    name,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    accessLevel?: AccessLevel;
    comment?: Comments;
    isStatic?: boolean;
    multiLine?: boolean;
    name: string;
    parameters?: ReadonlyArray<FunctionParameter>;
    returnType?: string | typescript34.TypeNode;
    statements?: typescript34.Statement[];
    types?: FunctionTypeParameter[];
  }) => typescript34.MethodDeclaration;
  namedImportDeclarations: ({
    imports,
    module: module_d_exports
  }: {
    imports: Array<ImportExportItem> | ImportExportItem;
    module: string;
  }) => typescript34.ImportDeclaration;
  namespaceDeclaration: ({
    name,
    statements
  }: {
    name: string;
    statements: Array<typescript34.Statement>;
  }) => typescript34.ModuleDeclaration;
  newExpression: ({
    argumentsArray,
    expression,
    typeArguments
  }: {
    argumentsArray?: Array<typescript34.Expression>;
    expression: typescript34.Expression;
    typeArguments?: Array<typescript34.TypeNode>;
  }) => typescript34.NewExpression;
  nodeToString: typeof tsNodeToString;
  null: () => typescript34.NullLiteral;
  objectExpression: <T extends Record<string, any> | Array<ObjectValue>>({
    comments,
    identifiers,
    multiLine,
    obj,
    shorthand,
    unescape
  }: {
    comments?: Comments;
    identifiers?: string[];
    multiLine?: boolean;
    obj: T;
    shorthand?: boolean;
    unescape?: boolean;
  }) => typescript34.ObjectLiteralExpression;
  ots: {
    boolean: (value: boolean) => typescript34.TrueLiteral | typescript34.FalseLiteral;
    export: ({
      alias,
      asType,
      name
    }: ImportExportItemObject) => typescript34.ExportSpecifier;
    import: ({
      alias,
      asType,
      name
    }: ImportExportItemObject) => typescript34.ImportSpecifier;
    number: (value: number) => typescript34.NumericLiteral | typescript34.PrefixUnaryExpression;
    string: (value: string, unescape?: boolean) => typescript34.Identifier | typescript34.StringLiteral;
  };
  parameterDeclaration: ({
    initializer,
    modifiers,
    name,
    required,
    type
  }: {
    initializer?: typescript34.Expression;
    modifiers?: ReadonlyArray<typescript34.ModifierLike>;
    name: string | typescript34.BindingName;
    required?: boolean;
    type?: typescript34.TypeNode;
  }) => typescript34.ParameterDeclaration;
  prefixUnaryExpression: ({
    expression,
    prefix
  }: {
    expression: string | typescript34.Expression;
    prefix: ("-" | "!") | typescript34.PrefixUnaryOperator;
  }) => typescript34.PrefixUnaryExpression;
  propertyAccessExpression: ({
    expression,
    isOptional,
    name
  }: {
    expression: string | typescript34.Expression;
    isOptional?: boolean;
    name: string | number | typescript34.MemberName;
  }) => typescript34.PropertyAccessChain | typescript34.PropertyAccessExpression | typescript34.ElementAccessExpression;
  propertyAccessExpressions: ({
    expressions
  }: {
    expressions: Array<string | typescript34.Expression | typescript34.MemberName>;
  }) => typescript34.PropertyAccessExpression;
  propertyAssignment: ({
    initializer,
    name
  }: {
    initializer: typescript34.Expression;
    name: string | typescript34.PropertyName;
  }) => typescript34.PropertyAssignment;
  propertyDeclaration: ({
    initializer,
    modifiers,
    name,
    type
  }: {
    initializer?: typescript34.Expression;
    modifiers?: Modifier | ReadonlyArray<Modifier>;
    name: string | typescript34.PropertyName;
    type?: typescript34.TypeNode;
  }) => typescript34.PropertyDeclaration;
  regularExpressionLiteral: ({
    flags,
    text
  }: {
    flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
    text: string;
  }) => typescript34.RegularExpressionLiteral;
  returnFunctionCall: ({
    args,
    name,
    types: types_d_exports
  }: {
    args: any[];
    name: string | typescript34.Expression;
    types?: ReadonlyArray<string | typescript34.StringLiteral>;
  }) => typescript34.ReturnStatement;
  returnStatement: ({
    expression
  }: {
    expression?: typescript34.Expression;
  }) => typescript34.ReturnStatement;
  returnVariable: ({
    expression
  }: {
    expression: string | typescript34.Expression;
  }) => typescript34.ReturnStatement;
  safeAccessExpression: (path: string[]) => typescript34.Expression;
  stringLiteral: ({
    isSingleQuote,
    text
  }: {
    isSingleQuote?: boolean;
    text: string;
  }) => typescript34.StringLiteral;
  templateLiteralType: ({
    value
  }: {
    value: ReadonlyArray<string | typescript34.TypeNode>;
  }) => typescript34.TemplateLiteralTypeNode;
  this: () => typescript34.ThisExpression;
  transformArrayMap: ({
    path,
    transformExpression
  }: {
    path: string[];
    transformExpression: typescript34.Expression;
  }) => typescript34.IfStatement;
  transformArrayMutation: ({
    path,
    transformerName
  }: {
    path: string[];
    transformerName: string;
  }) => typescript34.Statement;
  transformDateMutation: ({
    path
  }: {
    path: string[];
  }) => typescript34.Statement;
  transformFunctionMutation: ({
    path,
    transformerName
  }: {
    path: string[];
    transformerName: string;
  }) => typescript34.IfStatement[];
  transformNewDate: ({
    parameterName
  }: {
    parameterName: string;
  }) => typescript34.NewExpression;
  typeAliasDeclaration: ({
    comment,
    exportType,
    name,
    type,
    typeParameters
  }: {
    comment?: Comments;
    exportType?: boolean;
    name: string | typescript34.TypeReferenceNode;
    type: string | typescript34.TypeNode | typescript34.Identifier;
    typeParameters?: FunctionTypeParameter[];
  }) => typescript34.TypeAliasDeclaration;
  typeArrayNode: (types: ReadonlyArray<any | typescript34.TypeNode> | typescript34.TypeNode | typescript34.Identifier | string, isNullable?: boolean) => typescript34.TypeNode;
  typeInterfaceNode: ({
    indexKey,
    indexProperty,
    isNullable,
    properties,
    useLegacyResolution
  }: {
    indexKey?: typescript34.TypeReferenceNode;
    indexProperty?: Property;
    isNullable?: boolean;
    properties: Property[];
    useLegacyResolution: boolean;
  }) => typescript34.TypeNode;
  typeIntersectionNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: (any | typescript34.TypeNode)[];
  }) => typescript34.TypeNode;
  typeNode: (base: any | typescript34.TypeNode, args?: (any | typescript34.TypeNode)[]) => typescript34.TypeNode;
  typeOfExpression: ({
    text
  }: {
    text: string | typescript34.Identifier;
  }) => typescript34.TypeOfExpression;
  typeOperatorNode: ({
    operator,
    type
  }: {
    operator: "keyof" | "readonly" | "unique";
    type: typescript34.TypeNode;
  }) => typescript34.TypeOperatorNode;
  typeParameterDeclaration: ({
    constraint,
    defaultType,
    modifiers,
    name
  }: {
    constraint?: typescript34.TypeNode;
    defaultType?: typescript34.TypeNode;
    modifiers?: Array<typescript34.Modifier>;
    name: string | typescript34.Identifier;
  }) => typescript34.TypeParameterDeclaration;
  typeParenthesizedNode: ({
    type
  }: {
    type: typescript34.TypeNode;
  }) => typescript34.ParenthesizedTypeNode;
  typeRecordNode: (keys: (any | typescript34.TypeNode)[], values: (any | typescript34.TypeNode)[], isNullable?: boolean, useLegacyResolution?: boolean) => typescript34.TypeNode;
  typeReferenceNode: ({
    typeArguments,
    typeName
  }: {
    typeArguments?: typescript34.TypeNode[];
    typeName: string | typescript34.EntityName;
  }) => typescript34.TypeReferenceNode;
  typeTupleNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: Array<any | typescript34.TypeNode>;
  }) => typescript34.TypeNode;
  typeUnionNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: ReadonlyArray<any | typescript34.TypeNode>;
  }) => typescript34.TypeNode;
  valueToExpression: <T = unknown>({
    identifiers,
    isValueAccess,
    shorthand,
    unescape,
    value
  }: {
    identifiers?: string[];
    isValueAccess?: boolean;
    shorthand?: boolean;
    unescape?: boolean;
    value: T;
  }) => typescript34.Expression | undefined;
};
/** @deprecated use tsc */
declare const compiler: {
  anonymousFunction: ({
    async,
    comment,
    multiLine,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    async?: boolean;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: FunctionParameter[];
    returnType?: string | typescript34.TypeNode;
    statements?: ReadonlyArray<typescript34.Statement>;
    types?: FunctionTypeParameter[];
  }) => typescript34.FunctionExpression;
  arrayLiteralExpression: <T>({
    elements,
    multiLine
  }: {
    elements: T[];
    multiLine?: boolean;
  }) => typescript34.ArrayLiteralExpression;
  arrowFunction: ({
    async,
    comment,
    multiLine,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    async?: boolean;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: ReadonlyArray<FunctionParameter>;
    returnType?: string | typescript34.TypeNode;
    statements?: typescript34.Statement[] | typescript34.Expression;
    types?: FunctionTypeParameter[];
  }) => typescript34.ArrowFunction;
  asExpression: ({
    expression,
    type
  }: {
    expression: typescript34.Expression;
    type: typescript34.TypeNode;
  }) => typescript34.AsExpression;
  assignment: ({
    left,
    right
  }: {
    left: typescript34.Expression;
    right: typescript34.Expression;
  }) => typescript34.AssignmentExpression<typescript34.EqualsToken>;
  awaitExpression: ({
    expression
  }: {
    expression: typescript34.Expression;
  }) => typescript34.AwaitExpression;
  binaryExpression: ({
    left,
    operator,
    right
  }: {
    left: typescript34.Expression;
    operator?: "=" | "===" | "!==" | "in" | "??";
    right: typescript34.Expression | string;
  }) => typescript34.BinaryExpression;
  block: ({
    multiLine,
    statements
  }: {
    multiLine?: boolean;
    statements: ReadonlyArray<typescript34.Statement>;
  }) => typescript34.Block;
  callExpression: ({
    functionName,
    parameters,
    types: types_d_exports
  }: {
    functionName: string | typescript34.PropertyAccessExpression | typescript34.PropertyAccessChain | typescript34.ElementAccessExpression | typescript34.Expression;
    parameters?: Array<string | typescript34.Expression | undefined>;
    types?: ReadonlyArray<typescript34.TypeNode>;
  }) => typescript34.CallExpression;
  classDeclaration: ({
    decorator,
    exportClass,
    extendedClasses,
    name,
    nodes,
    typeParameters
  }: {
    decorator?: {
      args: any[];
      name: string;
    };
    exportClass?: boolean;
    extendedClasses?: ReadonlyArray<string>;
    name: string;
    nodes: ReadonlyArray<typescript34.ClassElement>;
    typeParameters?: ReadonlyArray<typescript34.TypeParameterDeclaration>;
  }) => typescript34.ClassDeclaration;
  conditionalExpression: ({
    condition,
    whenFalse,
    whenTrue
  }: {
    condition: typescript34.Expression;
    whenFalse: typescript34.Expression;
    whenTrue: typescript34.Expression;
  }) => typescript34.ConditionalExpression;
  constVariable: ({
    assertion,
    comment,
    destructure,
    exportConst,
    expression,
    name,
    typeName
  }: {
    assertion?: "const" | typescript34.TypeNode;
    comment?: Comments;
    destructure?: boolean;
    exportConst?: boolean;
    expression: typescript34.Expression;
    name: string | typescript34.TypeReferenceNode;
    typeName?: string | typescript34.IndexedAccessTypeNode | typescript34.TypeNode;
  }) => typescript34.VariableStatement;
  constructorDeclaration: ({
    accessLevel,
    comment,
    multiLine,
    parameters,
    statements
  }: {
    accessLevel?: AccessLevel;
    comment?: Comments;
    multiLine?: boolean;
    parameters?: FunctionParameter[];
    statements?: typescript34.Statement[];
  }) => typescript34.ConstructorDeclaration;
  enumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({
    asConst,
    comments: enumMemberComments,
    leadingComment: comments,
    name,
    obj
  }: {
    asConst: boolean;
    comments?: Record<string | number, Comments>;
    leadingComment?: Comments;
    name: string | typescript34.TypeReferenceNode;
    obj: T;
  }) => typescript34.EnumDeclaration;
  exportAllDeclaration: ({
    module: module_d_exports,
    shouldAppendJs
  }: {
    module: string;
    shouldAppendJs?: boolean;
  }) => typescript34.ExportDeclaration;
  exportNamedDeclaration: ({
    exports,
    module: module_d_exports
  }: {
    exports: Array<ImportExportItem> | ImportExportItem;
    module: string;
  }) => typescript34.ExportDeclaration;
  expressionToStatement: ({
    expression
  }: {
    expression: typescript34.Expression;
  }) => typescript34.ExpressionStatement;
  forOfStatement: ({
    awaitModifier,
    expression,
    initializer,
    statement
  }: {
    awaitModifier?: typescript34.AwaitKeyword;
    expression: typescript34.Expression;
    initializer: typescript34.ForInitializer;
    statement: typescript34.Statement;
  }) => typescript34.ForOfStatement;
  functionTypeNode: ({
    parameters,
    returnType,
    typeParameters
  }: {
    parameters?: typescript34.ParameterDeclaration[];
    returnType: typescript34.TypeNode;
    typeParameters?: typescript34.TypeParameterDeclaration[];
  }) => typescript34.FunctionTypeNode;
  getAccessorDeclaration: ({
    modifiers,
    name,
    returnType,
    statements
  }: {
    modifiers?: Modifier | ReadonlyArray<Modifier>;
    name: string | typescript34.PropertyName;
    returnType?: string | typescript34.Identifier;
    statements: ReadonlyArray<typescript34.Statement>;
  }) => typescript34.GetAccessorDeclaration;
  identifier: (args: string | {
    text: string;
  }) => typescript34.Identifier;
  ifStatement: ({
    elseStatement,
    expression,
    thenStatement
  }: {
    elseStatement?: typescript34.Statement;
    expression: typescript34.Expression;
    thenStatement: typescript34.Statement;
  }) => typescript34.IfStatement;
  indexedAccessTypeNode: ({
    indexType,
    objectType
  }: {
    indexType: typescript34.TypeNode;
    objectType: typescript34.TypeNode;
  }) => typescript34.IndexedAccessTypeNode;
  isTsNode: (node: any) => node is typescript34.Expression;
  keywordTypeNode: ({
    keyword
  }: {
    keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
  }) => typescript34.KeywordTypeNode<typescript34.SyntaxKind.VoidKeyword | typescript34.SyntaxKind.AnyKeyword | typescript34.SyntaxKind.BooleanKeyword | typescript34.SyntaxKind.NeverKeyword | typescript34.SyntaxKind.NumberKeyword | typescript34.SyntaxKind.StringKeyword | typescript34.SyntaxKind.UndefinedKeyword | typescript34.SyntaxKind.UnknownKeyword>;
  literalTypeNode: ({
    literal
  }: {
    literal: typescript34.LiteralTypeNode["literal"];
  }) => typescript34.LiteralTypeNode;
  mappedTypeNode: ({
    members,
    nameType,
    questionToken,
    readonlyToken,
    type,
    typeParameter
  }: {
    members?: typescript34.NodeArray<typescript34.TypeElement>;
    nameType?: typescript34.TypeNode;
    questionToken?: typescript34.QuestionToken | typescript34.PlusToken | typescript34.MinusToken;
    readonlyToken?: typescript34.ReadonlyKeyword | typescript34.PlusToken | typescript34.MinusToken;
    type?: typescript34.TypeNode;
    typeParameter: typescript34.TypeParameterDeclaration;
  }) => typescript34.MappedTypeNode;
  methodDeclaration: ({
    accessLevel,
    comment,
    isStatic,
    multiLine,
    name,
    parameters,
    returnType,
    statements,
    types: types_d_exports
  }: {
    accessLevel?: AccessLevel;
    comment?: Comments;
    isStatic?: boolean;
    multiLine?: boolean;
    name: string;
    parameters?: ReadonlyArray<FunctionParameter>;
    returnType?: string | typescript34.TypeNode;
    statements?: typescript34.Statement[];
    types?: FunctionTypeParameter[];
  }) => typescript34.MethodDeclaration;
  namedImportDeclarations: ({
    imports,
    module: module_d_exports
  }: {
    imports: Array<ImportExportItem> | ImportExportItem;
    module: string;
  }) => typescript34.ImportDeclaration;
  namespaceDeclaration: ({
    name,
    statements
  }: {
    name: string;
    statements: Array<typescript34.Statement>;
  }) => typescript34.ModuleDeclaration;
  newExpression: ({
    argumentsArray,
    expression,
    typeArguments
  }: {
    argumentsArray?: Array<typescript34.Expression>;
    expression: typescript34.Expression;
    typeArguments?: Array<typescript34.TypeNode>;
  }) => typescript34.NewExpression;
  nodeToString: typeof tsNodeToString;
  null: () => typescript34.NullLiteral;
  objectExpression: <T extends Record<string, any> | Array<ObjectValue>>({
    comments,
    identifiers,
    multiLine,
    obj,
    shorthand,
    unescape
  }: {
    comments?: Comments;
    identifiers?: string[];
    multiLine?: boolean;
    obj: T;
    shorthand?: boolean;
    unescape?: boolean;
  }) => typescript34.ObjectLiteralExpression;
  ots: {
    boolean: (value: boolean) => typescript34.TrueLiteral | typescript34.FalseLiteral;
    export: ({
      alias,
      asType,
      name
    }: ImportExportItemObject) => typescript34.ExportSpecifier;
    import: ({
      alias,
      asType,
      name
    }: ImportExportItemObject) => typescript34.ImportSpecifier;
    number: (value: number) => typescript34.NumericLiteral | typescript34.PrefixUnaryExpression;
    string: (value: string, unescape?: boolean) => typescript34.Identifier | typescript34.StringLiteral;
  };
  parameterDeclaration: ({
    initializer,
    modifiers,
    name,
    required,
    type
  }: {
    initializer?: typescript34.Expression;
    modifiers?: ReadonlyArray<typescript34.ModifierLike>;
    name: string | typescript34.BindingName;
    required?: boolean;
    type?: typescript34.TypeNode;
  }) => typescript34.ParameterDeclaration;
  prefixUnaryExpression: ({
    expression,
    prefix
  }: {
    expression: string | typescript34.Expression;
    prefix: ("-" | "!") | typescript34.PrefixUnaryOperator;
  }) => typescript34.PrefixUnaryExpression;
  propertyAccessExpression: ({
    expression,
    isOptional,
    name
  }: {
    expression: string | typescript34.Expression;
    isOptional?: boolean;
    name: string | number | typescript34.MemberName;
  }) => typescript34.PropertyAccessChain | typescript34.PropertyAccessExpression | typescript34.ElementAccessExpression;
  propertyAccessExpressions: ({
    expressions
  }: {
    expressions: Array<string | typescript34.Expression | typescript34.MemberName>;
  }) => typescript34.PropertyAccessExpression;
  propertyAssignment: ({
    initializer,
    name
  }: {
    initializer: typescript34.Expression;
    name: string | typescript34.PropertyName;
  }) => typescript34.PropertyAssignment;
  propertyDeclaration: ({
    initializer,
    modifiers,
    name,
    type
  }: {
    initializer?: typescript34.Expression;
    modifiers?: Modifier | ReadonlyArray<Modifier>;
    name: string | typescript34.PropertyName;
    type?: typescript34.TypeNode;
  }) => typescript34.PropertyDeclaration;
  regularExpressionLiteral: ({
    flags,
    text
  }: {
    flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
    text: string;
  }) => typescript34.RegularExpressionLiteral;
  returnFunctionCall: ({
    args,
    name,
    types: types_d_exports
  }: {
    args: any[];
    name: string | typescript34.Expression;
    types?: ReadonlyArray<string | typescript34.StringLiteral>;
  }) => typescript34.ReturnStatement;
  returnStatement: ({
    expression
  }: {
    expression?: typescript34.Expression;
  }) => typescript34.ReturnStatement;
  returnVariable: ({
    expression
  }: {
    expression: string | typescript34.Expression;
  }) => typescript34.ReturnStatement;
  safeAccessExpression: (path: string[]) => typescript34.Expression;
  stringLiteral: ({
    isSingleQuote,
    text
  }: {
    isSingleQuote?: boolean;
    text: string;
  }) => typescript34.StringLiteral;
  templateLiteralType: ({
    value
  }: {
    value: ReadonlyArray<string | typescript34.TypeNode>;
  }) => typescript34.TemplateLiteralTypeNode;
  this: () => typescript34.ThisExpression;
  transformArrayMap: ({
    path,
    transformExpression
  }: {
    path: string[];
    transformExpression: typescript34.Expression;
  }) => typescript34.IfStatement;
  transformArrayMutation: ({
    path,
    transformerName
  }: {
    path: string[];
    transformerName: string;
  }) => typescript34.Statement;
  transformDateMutation: ({
    path
  }: {
    path: string[];
  }) => typescript34.Statement;
  transformFunctionMutation: ({
    path,
    transformerName
  }: {
    path: string[];
    transformerName: string;
  }) => typescript34.IfStatement[];
  transformNewDate: ({
    parameterName
  }: {
    parameterName: string;
  }) => typescript34.NewExpression;
  typeAliasDeclaration: ({
    comment,
    exportType,
    name,
    type,
    typeParameters
  }: {
    comment?: Comments;
    exportType?: boolean;
    name: string | typescript34.TypeReferenceNode;
    type: string | typescript34.TypeNode | typescript34.Identifier;
    typeParameters?: FunctionTypeParameter[];
  }) => typescript34.TypeAliasDeclaration;
  typeArrayNode: (types: ReadonlyArray<any | typescript34.TypeNode> | typescript34.TypeNode | typescript34.Identifier | string, isNullable?: boolean) => typescript34.TypeNode;
  typeInterfaceNode: ({
    indexKey,
    indexProperty,
    isNullable,
    properties,
    useLegacyResolution
  }: {
    indexKey?: typescript34.TypeReferenceNode;
    indexProperty?: Property;
    isNullable?: boolean;
    properties: Property[];
    useLegacyResolution: boolean;
  }) => typescript34.TypeNode;
  typeIntersectionNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: (any | typescript34.TypeNode)[];
  }) => typescript34.TypeNode;
  typeNode: (base: any | typescript34.TypeNode, args?: (any | typescript34.TypeNode)[]) => typescript34.TypeNode;
  typeOfExpression: ({
    text
  }: {
    text: string | typescript34.Identifier;
  }) => typescript34.TypeOfExpression;
  typeOperatorNode: ({
    operator,
    type
  }: {
    operator: "keyof" | "readonly" | "unique";
    type: typescript34.TypeNode;
  }) => typescript34.TypeOperatorNode;
  typeParameterDeclaration: ({
    constraint,
    defaultType,
    modifiers,
    name
  }: {
    constraint?: typescript34.TypeNode;
    defaultType?: typescript34.TypeNode;
    modifiers?: Array<typescript34.Modifier>;
    name: string | typescript34.Identifier;
  }) => typescript34.TypeParameterDeclaration;
  typeParenthesizedNode: ({
    type
  }: {
    type: typescript34.TypeNode;
  }) => typescript34.ParenthesizedTypeNode;
  typeRecordNode: (keys: (any | typescript34.TypeNode)[], values: (any | typescript34.TypeNode)[], isNullable?: boolean, useLegacyResolution?: boolean) => typescript34.TypeNode;
  typeReferenceNode: ({
    typeArguments,
    typeName
  }: {
    typeArguments?: typescript34.TypeNode[];
    typeName: string | typescript34.EntityName;
  }) => typescript34.TypeReferenceNode;
  typeTupleNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: Array<any | typescript34.TypeNode>;
  }) => typescript34.TypeNode;
  typeUnionNode: ({
    isNullable,
    types: types_d_exports
  }: {
    isNullable?: boolean;
    types: ReadonlyArray<any | typescript34.TypeNode>;
  }) => typescript34.TypeNode;
  valueToExpression: <T = unknown>({
    identifiers,
    isValueAccess,
    shorthand,
    unescape,
    value
  }: {
    identifiers?: string[];
    isValueAccess?: boolean;
    shorthand?: boolean;
    unescape?: boolean;
    value: T;
  }) => typescript34.Expression | undefined;
};
//#endregion
//#region src/utils/exports.d.ts
declare const utils: {
  stringCase: ({
    case: _case,
    stripLeadingSeparators,
    value
  }: {
    readonly case: StringCase | undefined;
    stripLeadingSeparators?: boolean;
    value: string;
  }) => string;
};
//#endregion
//#region src/index.d.ts
declare module '@hey-api/codegen-core' {
  interface ProjectRenderMeta {
    /**
     * If specified, this will be the file extension used when importing
     * other modules. By default, we don't add a file extension and let the
     * runtime resolve it.
     *
     * @default null
     */
    importFileExtension?: (string & {}) | null;
  }
  interface SymbolMeta {
    category?: 'client' | 'external' | 'hook' | 'schema' | 'sdk' | 'transform' | 'type' | 'utility' | (string & {});
    /**
     * Path to the resource this symbol represents.
     */
    path?: ReadonlyArray<string | number>;
    /**
     * Name of the plugin that registered this symbol.
     */
    pluginName?: string;
    resource?: 'client' | 'definition' | 'operation' | 'webhook' | (string & {});
    resourceId?: string;
    role?: 'data' | 'error' | 'errors' | 'options' | 'response' | 'responses' | (string & {});
    /**
     * Tags associated with this symbol.
     */
    tags?: ReadonlyArray<string>;
    tool?: 'angular' | 'arktype' | 'fastify' | 'json-schema' | 'sdk' | 'typescript' | 'valibot' | 'zod' | (string & {});
    variant?: 'container' | (string & {});
  }
}
/**
 * Type helper for openapi-ts.config.ts, returns {@link MaybeArray<UserConfig>} object(s)
 */
declare const defineConfig: <T extends MaybeArray<UserConfig>>(config: LazyOrAsync<T>) => Promise<T>;
//#endregion
export { $, type Client as AngularClient, ArrayTsDsl, AttrTsDsl, AwaitTsDsl, type Client$1 as AxiosClient, BinaryTsDsl, CallTsDsl, ClassTsDsl, type Client$2 as Client, DecoratorTsDsl, type DefinePlugin, DescribeTsDsl, DollarTsDsl, ExprTsDsl, type ExpressionTransformer, type Client$3 as FetchClient, FieldTsDsl, FuncTsDsl, GetterTsDsl, type IR, IfTsDsl, InitTsDsl, LiteralTsDsl, Logger, MethodTsDsl, NewTsDsl, NewlineTsDsl, type Client$4 as NextClient, NotTsDsl, type Client$5 as NuxtClient, ObjectTsDsl, type Client$6 as OfetchClient, type OpenApi, type OpenApiMetaObject, type OpenApiOperationObject, type OpenApiParameterObject, type OpenApiRequestBodyObject, type OpenApiResponseObject, type OpenApiSchemaObject, ParamTsDsl, PatternTsDsl, type Plugin, RegExpTsDsl, ReturnTsDsl, SetterTsDsl, TemplateTsDsl, ThrowTsDsl, TsDsl, TypeAliasTsDsl, TypeAttrTsDsl, TypeExprTsDsl, TypeLiteralTsDsl, TypeObjectTsDsl, type TypeTransformer, type UserConfig, VarTsDsl, clientDefaultConfig, clientDefaultMeta, clientPluginHandler, compiler, createClient, defaultPaginationKeywords, defaultPlugins, defineConfig, definePluginConfig, tsc, utils };
//# sourceMappingURL=index.d.ts.map